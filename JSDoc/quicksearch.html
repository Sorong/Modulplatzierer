<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"Model_Roof.js.html":{"id":"Model_Roof.js.html","title":"Source: Model/Roof.js","body":" DocStrap Classes ControllerCookieHandlerEfficiencyDisplayMapMatrixPanelPanelStringRoofServerHandlerToolbar Global BEST_PVcalcNextPointcontrollerconvexHullCOOKIENAMEDAYS_TILL_COOKIE_EXPIREDEFAULT_ZOOMefficiencyTableevaluateEfficiencyHOSTINIT_LOCATIONinitAutocompletematrixSERVER_URL Source: Model/Roof.js /** * Bester Wert für die Effizienz anhand der Einstrahlungswerte. * * @constant * @type {number} */ const BEST_PV = 2; /** * Das Roof-Objekt repräsentiert ein Dach eines Gebäudes. * * @class * @constructor * * @property {number} gid - Die GebäudeID. * @property {number} roofId - Die ID der Dachfläche. * @property {L.latLng[]} points - Koordinaten der Dachfläche. * @property {number} pv - Eignung der Dachfläche für Photovoltaik-Module. * @property {number} st - Eignung der Dachfläche für die Solarthermie. * @property {number} orientation - Ausrichtung der Dachfläche in Richtung Süden in Grad. * @property {Roof[]} parts - Liste der Dachteilflächen. * @property {number} bestPart - Index der besten Dachteilfläche aus der Liste der Dachteilflächen. * Die Qualität wird anhand der besten PV-Eignung und den besten Einstrahlungswerten ermittelt. * @property {number} tilt - Der Winkel der Dachneigung in Grad. * @property {number} global - Die globalen Einstrahungswerte der Dachfläche. */ function Roof() { this.gid = 0; this.roofId = -1; this.points = []; this.pv = null; this.st = null; this.orientation = null; this.parts = null; this.bestPart = -1; this.tilt = 0; this.global = 0; } /** * Die Dachfläche wird anhand der übergebene Koordinaten, als konvexe Fläche ermittelt. * @see {convexHull} * @param {L.latLng[]} coordinates - Geo-Koordinaten der Dachfläche */ Roof.prototype.setPointsFromList = function (coordinates) { this.points = convexHull(coordinates); }; /** * Konvertiert ein Dach in ein Polygon, je nach Eignung wird die Farbe in Farbabstufung Rot (niedrige Eignung) bis Grün(hohe Eignung) gesetzt. * Außerdem wird die Polygonfläche einer Teilfläche mit dem jeweiligen Farbton gefüllt, während vom eigentlich Dach lediglich die Umrisse dargestellt werden. * @return {L.polygon} Dach als Polygon. */ Roof.prototype.getAsPolygon = function () { if(this.pv &gt; BEST_PV) {this.pv = 0;} var color_border = Math.floor(255 / BEST_PV); var red = (255 - (color_border * this.pv)) &lt;&lt; 16; var green = (color_border * this.pv) &lt;&lt; 8; var rgb = 0x000000; rgb |= red |= green; rgb = rgb.toString(16); while (rgb.length &lt; 6) { rgb = &quot;0&quot; + rgb; } var style = { color: &quot;#&quot; + rgb, weight: 2, fill: false }; if(this.parts === null) { style.weight = 1; style.fill = true; style.fillOpacity = 0.1; } return L.polygon(this.points, style); }; /** * Hier wird einem Dach eine Dachfläche hinzugefügt. Ein Dach ist eine Sammlung mehrerer Dachflächen, die für sich jeweils Dächer sind. * @param {Roof} part - Dach, welches dem Dach hinzugefügt wird. */ Roof.prototype.addPart = function (part) { if(this.parts === null) { this.parts = []; } var index = this.parts.push(part); if(this.bestPart === -1) {this.bestPart++;} var currentBest = this.parts[this.bestPart]; if(currentBest.pv &lt; part.pv || (currentBest.pv == part.pv &amp;&amp; currentBest.global &lt; part.global)) { this.bestPart = index-1; } this.global += part.global; }; /** * Getter für den zur Photovoltaik am besten geeigneten Dachteil. * @param {Controller} controller Wird benötigt, um ggf. die Ausrichtung der Dachteilfläche zu berechnen. * @return {Roof} Beste Teilfläche für die Photovoltaik. */ Roof.prototype.getBestRoofPart = function (controller) { if(this.bestPart === -1) { return this; } if(controller !== undefined &amp;&amp; this.parts[this.bestPart].orientation === null) { this.parts[this.bestPart].calculateOrientation(controller); } return this.parts[this.bestPart]; }; /** * Berechnung der Ausrichtung des Daches. * @param {Controller} controller Wird benötigt um die Geodaten in X/Y-Koordinaten zu transformieren um anhand dieser die Ausrichtung zu berechnen. */ Roof.prototype.calculateOrientation = function (controller) { var leftBot = rightBot = controller.getLatLngAsPoint(this.points[0]); for (var i = 0; i &lt; this.points.length; i++) { var current = controller.getLatLngAsPoint(this.points[i]); var current_next = controller.getLatLngAsPoint(this.points[(i + 1) % this.points.length]); if(current.y &gt;= leftBot.y) { leftBot = current; rightBot = current_next; } } rightBot.x-=leftBot.x; rightBot.y-=leftBot.y; leftBot.x= (leftBot.x+10) - leftBot.x; leftBot.y-=leftBot.y; var cos_theta = ((leftBot.x * rightBot.x) + (leftBot.y * rightBot.y)) / (Math.sqrt(Math.pow(leftBot.x, 2) + Math.pow(leftBot.y, 2)) * Math.sqrt(Math.pow(rightBot.x, 2) + Math.pow(rightBot.y, 2))); var angle = Math.acos(cos_theta) / Math.PI * 180; this.orientation = isNaN(angle) ? 0 : angle; }; /** * Die Funktion überprüft ob sich ein Panel innerhalb eines Dachs befindet. * Sollte sich das Panel ausserhalb des Dachs befinden, wird false zurückgegeben, sonst true. * * @param {Panel|PanelString} panel - Panel- oder PanelString-Objekt * @return {boolean} Gibt an ob sich die Panels auf dem Dach befinden */ Roof.prototype.panelInRoof = function (panel) { var list = panel.getPointsAsList(); var inside = false; var insideCounter = 0; for(var li = 0; li &lt; list.length; li++) { for(var i = 0, j = this.points.length-1; i &lt; this.points.length; j = i++){ var roofFirst = controller.getLatLngAsPoint(this.points[i]); var roofSecond = controller.getLatLngAsPoint(this.points[j]); var testPoint = controller.getLatLngAsPoint(list[li]); if( ((roofFirst.y &gt; testPoint.y) != (roofSecond.y &gt;testPoint.y)) &amp;&amp; (testPoint.x &lt; (roofSecond.x - roofFirst.x) * (testPoint.y - roofFirst.y) / (roofSecond.y-roofFirst.y) + roofFirst.x)) { inside = !inside; } } if(inside) { insideCounter++; } inside = false; } return insideCounter === list.length; }; /** * @typedef {Object} DachJson * @property {number} dach_id - DachID * @property {number} gid - GebäudeID * @property {number} st - Eignung für die Solarthermie. * @property {number} pv - Eignung für die Photovoltaik. * @property {number} tilt - Dachneigung in Grad. * @property {number} global - Einstrahlungswerte der Dachfläche. * @property {number[][]} the_geom - Array der Form [...[latitude, longitude],[latitude, longitude]...]. */ /** * Gibt uns das Dachobjekt als Json zurück * * @return {DachJson} Dach als Json */ Roof.prototype.getAsJson = function () { var geom = []; for(var i = 0; i &lt; this.points.length; i++) { geom.push({ latitude: this.points[i].lat, longitude : this.points[i].lng }) } return { dach_id : this.roofId, gid : this.gid, st : this.st, pv : this.pv, tilt : this.tilt, global : this.global, the_geom : geom } }; /* Hilfsfunktion */ /** * Es wird aus den übergeben Punkten die konvexe Hülle erstellt. * @see {@link https://de.wikipedia.org/wiki/Graham_Scan} * @param {Array.&lt;Array.&lt;number, number&gt;&gt;} points - Alle Koordinaten der Dachfläche. * @return {Array.&lt;Array.&lt;number, number&gt;&gt;} Koordinaten der konvexen Hülle. */ function convexHull(points) { function cross(o, a, b) { return (a.lng - o.lng) * (b.lat - o.lat) - (a.lat - o.lat) * (b.lng - o.lng); } points.sort(function (a, b) { return a.lng == b.lng ? a.lat - b.lat : a.lng - b.lng; }); var lower = []; for (var i = 0; i &lt; points.length; i++) { while (lower.length &gt;= 2 &amp;&amp; cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) &lt;= 0) { lower.pop(); } lower.push(points[i]); } var upper = []; for (var j = points.length - 1; j &gt;= 0; j--) { while (upper.length &gt;= 2 &amp;&amp; cross(upper[upper.length - 2], upper[upper.length - 1], points[j]) &lt;= 0) { upper.pop(); } upper.push(points[j]); } upper.pop(); lower.pop(); return lower.concat(upper); } × Search results Close "},"Model_Panel.js.html":{"id":"Model_Panel.js.html","title":"Source: Model/Panel.js","body":" DocStrap Classes ControllerCookieHandlerEfficiencyDisplayMapMatrixPanelPanelStringRoofServerHandlerToolbar Global BEST_PVcalcNextPointcontrollerconvexHullCOOKIENAMEDAYS_TILL_COOKIE_EXPIREDEFAULT_ZOOMefficiencyTableevaluateEfficiencyHOSTINIT_LOCATIONinitAutocompletematrixSERVER_URL Source: Model/Panel.js /** * Matrix-Objekt, dass zur Berechnung der Drehungen genutzt wird. * @type {Matrix} */ var matrix = new Matrix(); /** * Konstruiert ein Solarpanel (Panel-Objekt). * @constructor * @property {L.latLng} oTopLeft Stellt die Ursprungskoordinaten für den Punkt im Nordwesten dar. * @property {L.latLng} oTopRight Stellt die Ursprungskoordinaten für den Punkt im Nordosten dar. * @property {L.latLng} oBotLeft Stellt die Ursprungskoordinaten für den Punkt im Südwesten dar. * @property {L.latLng} oBotLeft Stellt die Ursprungskoordinaten für den Punkt im Südosten dar. * @property {L.latLng} topLeft Stellt die Koordinaten für den Punkt im Nordwesten, unter Berücksichtigung der Rotation, dar. * @property {L.latLng} topRight Stellt die Koordinaten für den Punkt im Nordosten, unter Berücksichtigung der Rotation, dar. * @property {L.latLng} botLeft Stellt die Koordinaten für den Punkt im Südwesten, unter Berücksichtigung der Rotation, dar. * @property {L.latLng} botRight Stellt die Koordinaten für den Punkt im Südosten, unter Berücksichtigung der Rotation, dar. * @property {number} orientation Die Rotation entlang der Paneleigenen Z-Achse. * @property {string} pitch Die Rotation entlang der Paneleigenen X-Achse. * @property {number} height Die Höhe/Länge des Panels in Meter. * @property {number} width Die Breite des Panels in Meter. * @property {number} frameWidth Die Rahmenbreite des Panels in Meter. * @property {number} id Die ID des Panels. * */ function Panel() { this.oTopLeft = null; this.oTopRight = null; this.oBotLeft = null; this.oBotRight = null; this.topLeft = null; this.topRight = null; this.botLeft = null; this.botRight = null; this.orientation = 0; this.pitch = 0; this.name = null; this.height = 0; this.width = 0; this.frameWidth = 0.05; this.id = -1; } /** * Justiert das Panel neu aufgrund von veränderten Koordinaten oder veränderte Breite/Länge. * @param {Controller} controller Der Controller der benötigt wird um Koordinaten von Geodaten in X/Y-Koordinaten umzurechnen. * @param {number|undefined} width Neue Breite des Panels, wenn nicht definiert, wird die bereits vorhandene Breite genutzt. * @param {number|undefined} height Neue Länge/Höhe des Panels, wenn nicht definiert, wird die bereits vorhande Länge genutzt. */ Panel.prototype.align = function (controller, width, height) { var w = width !== undefined ? width : this.width; var h = height !== undefined ? height : this.height; var frameInMeter = this.frameWidth; this.oTopLeft = this.topLeft; this.oTopRight = calcNextPoint(Number(this.width) + frameInMeter, this.oTopLeft, 0); this.oBotLeft = calcNextPoint(Number(this.height) + frameInMeter, this.oTopLeft, -90); this.oBotRight = calcNextPoint(Number(this.height) + frameInMeter, this.oTopRight, -90); this.width = w; this.height = h; this._selfAlign(controller); }; /** * Verarbeitet die definierten Rotationswinkel (pitch/orientation) um die transformierten Koordinaten zu berechnen. * @param {Controller} controller Der Controller der benötigt wird um Koordinaten von Geodaten in X/Y-Koordinaten umzurechnen. * @private */ Panel.prototype._selfAlign = function (controller) { this.topLeft = controller.getLatLngAsPoint(this.oTopLeft); this.topRight = controller.getLatLngAsPoint(this.oTopRight); this.botLeft = controller.getLatLngAsPoint(this.oBotLeft); this.botRight = controller.getLatLngAsPoint(this.oBotRight); var vTopBottomLeft = [ this.botLeft.x - this.topLeft.x, this.botLeft.y - this.topLeft.y, 0 ]; var vTopBottomRight = [ this.botRight.x - this.topLeft.x, this.botRight.y - this.topLeft.y, 0 ]; var vTopLeftTopRight = [ this.topRight.x - this.topLeft.x, this.topRight.y - this.topLeft.y, 0]; var orientationMatrix = matrix.calculateOrientationMatrix(this.orientation); var pitchMatrix = matrix.calculatePitchMatrix(this.pitch); var topright = matrix.matrixMultiplyVector(orientationMatrix, vTopLeftTopRight); var bottomleft = matrix.matrixMultiplyVector(orientationMatrix, matrix.matrixMultiplyVector(pitchMatrix, vTopBottomLeft)); var bottomright = matrix.matrixMultiplyVector(orientationMatrix, matrix.matrixMultiplyVector(pitchMatrix, vTopBottomRight)); this.botLeft = controller.getPointAsLatLng([this.topLeft.x + bottomleft[0], this.topLeft.y + bottomleft[1]]); this.topRight = controller.getPointAsLatLng([this.topLeft.x + topright[0], this.topLeft.y + topright[1]]); this.botRight = controller.getPointAsLatLng([this.topLeft.x + bottomright[0], this.topLeft.y + bottomright[1]]); this.topLeft = controller.getPointAsLatLng([this.topLeft.x, this.topLeft.y]); }; /** * Berechnet die Rahmenbreite in Pixel. * @param {Controller} controller Der Controller der benötigt wird um Koordinaten von Geodaten in X/Y-Koordinaten umzurechnen. * @returns {number} Die Rahmenbreite in Pixel. */ Panel.prototype.getFrameWidthInPixel = function (controller) { var frameInMeter = this.frameWidth; console.log(&quot;Zentimeter&quot; + frameInMeter); var vectorFrame = calcNextPoint(frameInMeter, this.oTopLeft, 0); vectorFrame = controller.getLatLngAsPoint(vectorFrame); vectorWithoutFrame = controller.getLatLngAsPoint(this.oTopLeft); return (vectorFrame.x - vectorWithoutFrame.x); }; /** * Getter für die Rahmenbreite. * @returns {number} Rahmenbreite in Metern. */ Panel.prototype.getFrameWidth = function () { return this.frameWidth; }; /** * Setter für die Rahmenbreite. * @param {Controller} controller Der Controller der zur Berechnung der Panelgrößen notwendig ist, interner Aufruf von align {@see align} * @param {number} width Die neue Rahmenbreite in Metern. */ Panel.prototype.setFrameWidth = function (controller, width) { this.frameWidth = width; this.align(controller); }; /** * Setter für die Ausrichtung des Panels. * @param {Controller} controller Der Controller der zur Berechnung der Panelgrößen notwendig ist, interner Aufruf von align {@see align} * @param {number} orientation Die neue Ausrichtung des Panels in Grad. */ Panel.prototype.setOrientation = function (controller, orientation) { this.orientation = orientation; this.align(controller) }; /** * Setter für die Neigung des Panels. * @param {Controller} controller Der Controller der zur Berechnung der Panelgrößen notwendig ist, interner Aufruf von align {@see align} * @param {number} pitch Die neue Neigung des Panels in Grad. */ Panel.prototype.setPitch = function (controller, pitch) { this.pitch = pitch; this.align(controller); }; /** * Setter für die nordwestlichste Koordinate des Panels. * @param {Controller} controller Der Controller der zur Berechnung der Panelgrößen notwendig ist, interner Aufruf von align {@see align} * @param {L.latLng} topLeft Geodaten der Koordinate. */ Panel.prototype.setTopLeft = function (controller, topLeft) { this.topLeft = topLeft; this.align(controller) }; /** * Konvertiert die Punkte des Panels in ein Listenformat ([NW, NO, SO, SW]), Listenobjekte enhalten die Geodaten. * @returns {L.latLng[]} Array der Länge Vier. */ Panel.prototype.getPointsAsList = function () { return [this.oTopLeft, this.topRight, this.botRight, this.botLeft]; }; /** * Konvertiert die Punkte des Panels in ein Listenformat * ([[NW.latitude, NW.longitude], [NO.latitude, NW.longitude], [SO.latitude, SO.longitude], [SW.latitude, SW.longitude]]), * Listenobjekte enhalten die Geodaten. * @returns {number[][]} Array der Länge Vier. Jeder Eintrag enthält ein Array der Länge Zwei [Latitude, Longitude]. */ Panel.prototype.getLatLngsAsArray = function () { return [ [this.topLeft.lat, this.topLeft.lng], [this.topRight.lat, this.topRight.lng], [this.botRight.lat, this.botRight.lng], [this.botLeft.lat, this.botLeft.lng] ] }; /** * Konvertiert das Panel in ein JSON Objekt. * @returns JSON-Objekt mit allen Informationen des Panels. Attribute sind panel_id, the_geom[[latitude,longitude]], laenge, breite, neigung, ausrichtung und rahmenbreite. */ Panel.prototype.getAsJson = function () { return { panel_id: this.id, the_geom: [ { latitude: this.oTopLeft.lat, longitude: this.oTopLeft.lng }, { latitude: this.oTopRight.lat, longitude: this.oTopRight.lng }, { latitude: this.oBotRight.lat, longitude: this.oBotRight.lng }, { latitude: this.oBotLeft.lat, longitude: this.oBotLeft.lng }], laenge: this.height, breite: this.width, neigung: this.pitch, ausrichtung: this.orientation, rahmenbreite: this.frameWidth } }; /** * Liest die Punkte einer übergebenen Liste der Form Liste[[latitude, longitude]]. Und setzt anhand dieser die Panelkoordinaten neu. * @param {number[][]}list Liste der Länge Vier. Punkte werden der Reihe nach neu gesetzt: NW, NO, SW, SO. */ Panel.prototype.setPointsFromList = function (list) { if (list.length &gt; 0) { for (var i = 0; i &lt; list.length; i++) { var latLng = L.latLng(list[i].latitude, list[i].longitude); if (latLng === undefined) { latLng = list[i]; } switch (i) { case 0: this.oTopLeft = this.topLeft = latLng; break; case 1: this.oTopRight = latLng; break; case 2: this.oBotRight = latLng; break; case 3: this.oBotLeft = latLng; break; default: return; } } } }; /** * Getter für die ID des Panels. * @returns {number} ID des Panels. */ Panel.prototype.getId = function () { return this.id; }; /** * Hilfsfunktion zur Berechnung neuer Geodaten im Abhängigkeit zur Distanz in Metern, dem Ursprungspunkt und dem Winkel. * Zur internen Rechnung wird ein Erdradius von 6.371.000 Metern angenommen, wodurch geringfügige Abweichung zur tatsächlichen Größe möglich sein können. * @param {number} distance Der Abstand in Metern zum Ursprungspunkt. * @param {L.latLng} point Die Geodaten des Ursprungspunkt. * @param {number} angle Der Winkel, in Grad, in denen sich der Zielpunkt befinden soll. * @returns {l.latLng} Die Geodaten des berechnten Punktes. * @static */ function calcNextPoint(distance, point, angle) { earthRadius = 6371000; distanceNorth = Math.sin(angle * Math.PI / 180) * distance; distanceEast = Math.cos(angle * Math.PI / 180) * distance; if (isNaN(distanceNorth)) { distanceNorth = 0; } if (isNaN(distanceEast)) { distanceEast = 0; } newLat = point.lat + (distanceNorth / earthRadius) * (180 / Math.PI); newLon = point.lng + (distanceEast / earthRadius) * (180 / Math.PI) / Math.cos(point.lat * Math.PI / 180); return L.latLng(newLat, newLon); } × Search results Close "},"main.js.html":{"id":"main.js.html","title":"Source: main.js","body":" DocStrap Classes ControllerCookieHandlerEfficiencyDisplayMapMatrixPanelPanelStringRoofServerHandlerToolbar Global BEST_PVcalcNextPointcontrollerconvexHullCOOKIENAMEDAYS_TILL_COOKIE_EXPIREDEFAULT_ZOOMefficiencyTableevaluateEfficiencyHOSTINIT_LOCATIONinitAutocompletematrixSERVER_URL Source: main.js /** * Controller der aktuellen Sitzung. * @type {Controller} */ var controller = new Controller(); /** * Callback für das von Google genutzte Autocomplete Objekt zur Auflösung der Adressinformationen. * Der Controller der Sitzung wird initialisiert. */ function initAutocomplete() { controller.init(); } /** * Sobald die Internetseite erfolgreich geladen wurde, * wird der dargestellten Karte die korrekten Pixelmaße des HTML-Elements übermittelt. */ $(document).ready(function (){ controller.loadFromServer(); function resizeMap() { $(&quot;#map&quot;).height($(window).height() - 110); setTimeout(function () { controller.viewMap.map.invalidateSize(); }, 100); } resizeMap(); $(window).resize(function () { resizeMap() }); }); × Search results Close "},"Controller_Controller.js.html":{"id":"Controller_Controller.js.html","title":"Source: Controller/Controller.js","body":" DocStrap Classes ControllerCookieHandlerEfficiencyDisplayMapMatrixPanelPanelStringRoofServerHandlerToolbar Global BEST_PVcalcNextPointcontrollerconvexHullCOOKIENAMEDAYS_TILL_COOKIE_EXPIREDEFAULT_ZOOMefficiencyTableevaluateEfficiencyHOSTINIT_LOCATIONinitAutocompletematrixSERVER_URL Source: Controller/Controller.js /** * Gibt die Host-IP oder die DNS des Datenbankservers an. * * @constant * @type {string} */ const HOST = location.hostname; /** * Bestimmt die Dauer von neu erstellten Cookies in Tagen. * * @constant * @type {number} */ const DAYS_TILL_COOKIE_EXPIRE = 30; /** * Bestimmt den Namen der Cookies, die beim Nutzer abgelegt werden. * * @constant * @type {string} */ const COOKIENAME = &quot;Modulplatzierer&quot;; /** * Bestimmt den Pfad der für die Nutzung des RESTWebservices genutzt wird. * @constant * @type {string} */ const SERVER_URL = &quot;http://&quot; + HOST + &quot;:8080/SolarRESTService_war_exploded/&quot;; /** * Konstruiert ein Controller-Objekt. * Das Kontrollerobjekt wird bereits mit einem ServerHandler zur Kommunikation mit dem Datenbankserver, * einem CookieHandler zur Verwaltung und Interaktion des Benutzercookies * und einer Map, die die dargestellte Karte repräsentiert ausgestattet. * @class * @constructor * @property {boolean} serverIsAvailable Gibt an, ob der Datenbankserver zur Verfügung steht. * @property {Map} viewMap Hauptansicht der Karte * @property {google.maps.places.Autocomplete} viewAdress Das Objekt, dass die Adresseingabe ermöglicht. * @property {Toolbar} toolbar Werkzeugleiste zur Modifikation des Modells. * @property {ServerHandler} serverHandler Handler zur Nutzung der REST-Schnittstelle. * @property {CookieHandler} cookieHandler Handler zum Lesen und Schreiben von Cookies. * @property {Roof} roof Das aktuell dargestellte Dachmodell. * @property {number} cookieId Die vom Nutzer ausgelesene CookieID. * @property {EfficiencyDisplay} efficiencyDisplay Anzeige zur Darstellung der Effektivität. * */ function Controller() { this.serverIsAvailable = true; this.viewMap = new Map(); this.viewAddress = null; this.toolbar = null; this.serverHandler = new ServerHandler(SERVER_URL); this.serverHandler.errorFunction = callbackDisableServer; this.cookieHandler = new CookieHandler(COOKIENAME); this.roof = null; this.cookieId = null; this.efficiencyDisplay = null; this._setOrientation = null; } /** * Initialisiert den Controller, hier werden grundsätzliche Funktionen des Frontends, der View, verknüpft. * Hier wird der Knopf zum Hinzufügen weitere Modelle mit einem Clicklistener verknüpft. * Auch wird hier das Adresseingabefeld mit einem Listener zur Auswertung der eigebenen Adresse verbunden. * Außerdem werden die entsprechenden Viewkomponenten, wie die Karte, die Werkzeugleiste und die Darstellung der Effizienz initialisiert. */ Controller.prototype.init = function () { this.viewMap.controller = this; this.viewMap.init(); this.viewAddress = new google.maps.places.Autocomplete( (document.getElementById('address')), {types: ['geocode']}); var self = this; this.viewAddress.addListener('place_changed', function () { var place = self.viewAddress.getPlace(); self.getRoofFromServer(place); }); this.efficiencyDisplay = new EfficiencyDisplay(); this.showEfficiency(null); var addBtn = $('#add')[0]; addBtn.onclick = function () { var mapHeight = document.getElementById(&quot;map&quot;).offsetHeight; var mapWidth = document.getElementById(&quot;map&quot;).offsetWidth; var center = controller.viewMap.containerPointToLatLng(L.point(mapWidth / 2, mapHeight / 2)); var panelData = { name: &quot;Added Panel&quot;, LatLng: center }; var model = new Panel(); model.name = &quot;&quot;; model.width = 2; model.height = 2; model.topLeft = panelData.LatLng; model.orientation = self.roof === null ? 0 : self.roof.orientation; model.align(self); var panelstring = new PanelString(controller, model); panelstring = self.viewMap.addMultiPolygon(panelstring); self.saveToServer(panelstring.model.masterPanel, -1); self.getPanelEffiency(); } }; /** * Deaktiviert den Datenbankserver, wodurch weitere AJAX-Anfragen unterbunden werden. */ Controller.prototype.disableServer = function () { $('#error_output').removeClass('hidden'); this.serverIsAvailable = false; }; /** * Aktiviert den Datenbankserver, wodurch AJAX-Anfragen wieder ermöglicht werden. */ Controller.prototype.enableServer = function () { $('#error_output').addClass('hidden'); this.serverIsAvailable = true; }; /** * Liest den Cookie des Nutzers aus. Wenn kein Cookie vorhanden ist wird stattdessen ein neuer Cookie angelegt. * Sollte ein Cookie vorhanden sein wird der Cookie an den ServerHandler übergeben, * um die Informationen die mit dem Cookie verknüpft sind abzurufen. * * @param {boolean} forceNewCookie Erzwingt das Erstellen eines neuen Cookies. */ Controller.prototype.loadFromServer = function (forceNewCookie) { this.cookieId = this.cookieHandler.readCookie(); console.log(&quot;CookieID &quot; + this.cookieId + &quot; vom Nutzer gelesen&quot;); if (this.cookieId === null || this.cookieId === undefined || forceNewCookie === true) { var dueDate = new Date().getTime() + (DAYS_TILL_COOKIE_EXPIRE * 24 * 60 * 60 * 1000); var json = JSON.stringify({ cookie_id: 0, ablaufdatum: dueDate }); this.serverHandler.postCookie(json, callbackCreateCookie) } else { this.serverHandler.getCookie(this.cookieId, callbackEvaluateCookie) } }; /** * Stößt den Speicherprozess zur Speicherung eines Panels auf dem Datenbankserver an. * * @param {Panel} panel Muss ein Panelobjekt sein, sonst wird eine ungültige Anfrage an den Server gestellt. * @param {id} masterId Diese ID wird dem ServerHandler übergeben, um Panels zu einem Panelstring zu verbinden. * -1 signalisiert, dass das Panel der Beginn eines neuen Panelstrings ist. */ Controller.prototype.saveToServer = function (panel, masterId) { if (this.serverIsAvailable) { var json = this.convertModelToJsonString(panel, masterId); this.serverHandler.postPanel(json, panel, function (data, panel) { panel.id = data.panel_id; panel.name = &quot;Solarpanelstring &quot; + panel.id; }); } }; /** * Erstellt einen Cookie beim Benutzer * @param {number} cid Die CookieID die dem Nutzer zugeteilt werden soll. * @param {number} duedate Das Ablaufdatum als UNIX-Zeitstempel. */ Controller.prototype.createUserCookie = function (cid, duedate) { this.cookieId = cid; this.cookieHandler.createCookie(cid, duedate); }; /** * Löscht den Cookie des Benutzers. */ Controller.prototype.deleteUserCooke = function () { this.cookieHandler.eraseCookie(); this.loadFromServer(true); }; /** * Übermittelt dem mit dem Polygon verknüpftem Modell Positions und/oder Ausrichtungsänderungen. * Stößt den Speichervorgang zur Speicherung auf dem Datenbankserver an. * @param {L.Polygon} polygon Das Leafletpolygon, dass mit dem Modell verknüpft ist. * @param {L.latLng[][]} position Matrix mit den aktualisierten Koordinaten des Polygons. * @param {number} orientation Orientierung in Grad, in die das Polygon gedreht wurde. */ Controller.prototype.updateModel = function (polygon, position, orientation) { polygon.model.setPosition(position); if (orientation !== undefined) { polygon.model.setOrientation(orientation); } this.updatePolygonPosition(polygon); this.savePanelstring(polygon.model); this.getPanelEffiency(); }; /** * Verbindet ein Polygon mit der Toolbar um dessen Modifikation zu ermöglichen. * Hier werden die Listener für die HTML Elemente gesetzt, bzw. zuvorgesetzte Listener gelöscht, * damit auch nur das ausgewählte Polygon modifiziert wird. * @param {L.Polygon} polygon Das Polygon mit dem die Toolbar verknüpft wird. Das Polygon muss mit einem Modell verknüpft sein. */ Controller.prototype.connectModelWithToolbar = function (polygon) { var model = polygon.model.constructor === PanelString ? polygon.model.masterPanel : polygon.model; var isOtherPanelSelected = !(this.toolbar != null &amp;&amp; model == this.toolbar.selectedModel); if (this.toolbar === null) { this.toolbar = new Toolbar(model); } else if (isOtherPanelSelected) { this.toolbar.unbindEvents(); this.toolbar = null; this.toolbar = new Toolbar(model); } var self = this; var selected = self.viewMap.selectedPolygon; var changed = function () { if (this._setOrientation != null) { polygon.model.setOrientation(this._setOrientation); this._setOrientation = null; } if (self.serverIsAvailable) { for (var i = 0; i &lt; polygon.model.size(); i++) { var json = self.convertModelToJsonString(polygon.model.get(i), i === 0 ? -1 : polygon.model.get(0).id); self.serverHandler.updatePanel(json, function (data) { }); } } self.getPanelEffiency(); }; var realignModel = function (selectedPolygon, width, height) { selectedPolygon.model.align(self, width, height); self.updatePolygonPosition(selectedPolygon); }; this.toolbar.pitchSlider().on(&quot;input change&quot;, function () { if (polygon.model.constructor === PanelString) { selected.model.setPitch($(this).val()); } else { selected.model.pitch = $(this).val(); } realignModel(selected); }).mouseup(changed); this.toolbar.heightSlider().on(&quot;input change&quot;, function () { realignModel(selected, selected.model.width, $(this).val()); }).mouseup(changed); this.toolbar.widthSlider().on(&quot;input change&quot;, function () { realignModel(selected, $(this).val(), selected.model.height); }).mouseup(changed); this.toolbar.orientationSlider().on(&quot;input change&quot;, function () { var orientation = $(this).val(); if (polygon.model.constructor === PanelString) { polygon.transform.orientation(orientation); polygon.model.setOrientation(orientation); } else { selected.model.orientation = orientation; } realignModel(selected); }).mouseup(changed); this.toolbar.frameWidthSlider().on(&quot;input change&quot;, function () { if (polygon.model.constructor === PanelString) { selected.model.setFrameWidth(($(this).val()/100)); } else { selected.model.frameWidth = ($(this).val()/100); } selected.setStyle({weight: selected.model.getFrameWidth()}); realignModel(selected); }).mouseup(changed); this.toolbar.modelDelete.on(&quot;click&quot;, function () { for (var i = selected.model.size() - 1; i &gt;= 0; i--) { controller.removeModelById(selected.model.get(i).id); } controller.toolbar.unbindEvents(); controller.viewMap.removeSelected(); }) }; /** * Richtet ein Polygon anhand dessen Modell neu aus. * @param {L.polygon} polygon Das Polygon, das neu ausgerichtet werden soll. */ Controller.prototype.updatePolygonPosition = function (polygon) { polygon.model.align(this); polygon.setLatLngs(polygon.model.getPointsAsList()); polygon.transform.resetHandler(); }; /** * Verarbeitet, die vom Nutzer eingebene Adresse. Stößt Anfrage an den Datenbankserver an. * Die Adresse sollte die Straße, Hausnummer und den Ort enthalten, * ansonsten wird dem Benutzer ein Fehler angezeigt und es findet keine Anfrage an den Datenbankserver statt. * Bei gültiger Adresse wird vom Datenbankserver das Roof-Objekt erfragt. * @param {Place} place - Placeobjekt, welches verarbeitet werden soll. * @see {@link https://developers.google.com/maps/documentation/javascript/places?hl=de} für weitere Informationen. */ Controller.prototype.getRoofFromServer = function (place) { var self = this; if (place.geometry === undefined) { return; } var lat = place.geometry.location.lat(); var lng = place.geometry.location.lng(); var street, nr, citycode; for (var i = 0; i &lt; place.address_components.length; i++) { var curr = place.address_components[i]; if (curr.types[0] === &quot;route&quot;) { street = curr.long_name; } else if (curr.types[0] === &quot;street_number&quot;) { nr = curr.long_name; } else if (curr.types[0] === &quot;postal_code&quot;) { citycode = curr.long_name; } } if (street !== undefined &amp;&amp; nr !== undefined &amp;&amp; citycode !== undefined) { this.removeAddressError(); if (self.serverIsAvailable) { self.serverHandler.getPredefinedRoof(street, nr, citycode, callbackGetRoof) } } else { this.showAddressError(); } }; /** * Frag den Datenbankserver nach Teildächern des Daches. */ Controller.prototype.getRoofPartsFromServer = function () { if (this.serverIsAvailable &amp;&amp; this.roof != null) { this.serverHandler.getRoofParts(this.roof.gid, callbackGetRoofParts) } }; /** * Zeichnet ein Polygon auf die Karte, welche mit dem aktuellen Dachmodell verknüpft ist. * Außerdem wird der Speichervorgang angestoßen, mit dem beim erneuten Besuchen der Internetseite das selbe Dach automatisch abgerufen wird. */ Controller.prototype.drawRoof = function () { this.viewMap.removeAllNonMoveable(); if (this.serverIsAvailable &amp;&amp; this.roof.roofId === -1) { this.serverHandler.postRoof(this.convertModelToJsonString(this.roof), function (data) { console.log(&quot;Dach gespeichert&quot;); }); } this.viewMap.addNonMovable(this.roof); if (this.roof.parts != null &amp;&amp; this.roof.parts.length &gt; 0) { this.viewMap.addNonMovable(this.roof.getBestRoofPart(this)); } this.viewMap.setFocus(this.roof.points[0].lat, this.roof.points[0].lng); this.getPanelEffiency(); }; /** * Konvertiert ein L.latLng-Objekt in das entsprechende L.point-Objekt, relativ zur dargestellten Karte. * Somit lassen sich Geodaten in Pixelkoordinaten konvertieren. * @param {L.latLng} latLng Objekt mit den Geodaten. * @return {L.point} Den konvertierten Punkt. */ Controller.prototype.getLatLngAsPoint = function (latLng) { return this.viewMap.latLngToLayerPoint(latLng); }; /** * Konvertiert ein L.point-Objekt in das entsprechende L.latLng-Objekt. * Somit lassen sich Pixelkoordinaten in Geodaten konvertierten. * @param {L.point} point * @return {L.latLng} Die konvertierten Geodaten. */ Controller.prototype.getPointAsLatLng = function (point) { return this.viewMap.layerPointToLatLng(point); }; /** * Konvertiert ein Modell in einen JSON-String, zusätzlich werden dem JSON-String die aktuelle CookieID und ggf. die MasterpanelID hinzugefügt. * @param {Panel|PanelString|Roof} model Das Modell, das als JSON-String abgebildet werden soll. * @param {number} masterId ID des Masterpanels welche dem JSON-String hinzugefügt werden soll. * @return {string} JSON-String JSON-Objekt als String. */ Controller.prototype.convertModelToJsonString = function (model, masterId) { var json = model.getAsJson(); json.cookie_id = this.cookieId; if (masterId !== undefined) { json.masterpanel_id = masterId; } return JSON.stringify(json); }; /** * Fügt einem Panelstring ein neues Panel hinzu. Stößt Speichervorgang für das hinzugefügte Panel an. * @param {PanelString} model PanelString welcher erweitert werden soll. * @param {Panel} nextModel Panel, der hinzugefügt werden soll, wenn kein Panel übergeben wird, wird stattdessen ein neues Panel erstellt. */ Controller.prototype.appendModel = function (model, nextModel) { var appendModel = nextModel !== undefined ? nextModel : new Panel(); model.appendPanel(appendModel); if (appendModel.id === -1) { this.saveToServer(appendModel, model.masterPanel.id); } this.getPanelEffiency(); }; /** * Entfernt einem Panelstring ein Panel. * Stößt Löschvorgang auf dem Datenbankserver an um zu löschendes Panel aus der Datenbank zu entfernen. * @param {PanelString} model Der Panelstring, dem ein Panel entfernt werden soll. */ Controller.prototype.removeModel = function (model) { var id = model.removePanel(); if (id !== undefined &amp;&amp; id !== -1) { this.removeModelById(id); } this.getPanelEffiency(); }; /** * Löst Löschvorgang auf dem Datenbankserver aus. * @param {number} id Die ID, des Panels welches gelöscht werden soll. */ Controller.prototype.removeModelById = function (id) { if(this.serverIsAvailable) { this.serverHandler.removePanel(id, function () { console.log(id + &quot; wurde gelöscht&quot;); }) } }; /** * Stößt Aktualisierungsvorgang für einen kompletten Panelstring auf dem Datenbankserver an. * @param {PanelString} panelstring Panelstring, dessen Panels auf dem Datenbankserver aktualisiert werden sollen. */ Controller.prototype.savePanelstring = function (panelstring) { if (this.serverIsAvailable) { var masterpanelId = panelstring.get(0).id; for (var i = 0; i &lt; panelstring.size(); i++) { var json = this.convertModelToJsonString(panelstring.get(i), i === 0 ? -1 : masterpanelId); this.serverHandler.updatePanel(json, function (data) { }); } } }; /** * Liefert alle Geodaten eines Modells. * @param {PanelString|Panel} model Panel oder Panelstring, dessen Geodaten geliefert werden sollen. * @returns {Array} Alle Geodaten des entsprechenden Modells als Liste. */ Controller.prototype.getGeoJSON = function (model) { return model.getGeoJSON(); }; /* Adress-Error */ /** * Signalisiert dem Benutzer, dass die Adresseingabe ungültig ist. */ Controller.prototype.showAddressError = function () { $('#address_tool').addClass('has-error'); $('#address_tool_span').addClass('glyphicon-remove'); $('#address_error').text(&quot;Addresse muss aus Straße, Hausnummer und Ort bestehen.&quot;); }; /** * Signalisiert dem Benutzer, dass keine Dachdaten für die Adresse vorhanden sind. */ Controller.prototype.showCanNotFoundAddressError = function () { $('#address_tool').addClass('has-error'); $('#address_tool_span').addClass('glyphicon-remove'); $('#address_error').text(&quot;Keine Dachdaten der gewünschten Adresse abrufbar.&quot;); }; /** * Entfernt einen zuvor angezeigten AdressError. */ Controller.prototype.removeAddressError = function () { $('#address_tool').removeClass('has-error'); $('#address_tool_span').removeClass('glyphicon-remove'); $('#address_error').text(&quot;&quot;); }; /** * Erstellt ein Roof-Objekt aus den Koordinaten, die übergeben wurden. * @param {Array} data Datensatz der eingezeichnten Koordinaten. */ Controller.prototype.createRoof = function (data) { var type = data.layerType, layer = data.layer; layer.addTo(this.viewMap.map); //layer._latlngs hat die Koordinaten // oder layer.editing.latlngs $(layer).on('click', function () { if (layer.editing._enabled) { layer.editing.disable() } else { layer.editing.enable() } }); this.viewMap.map.removeLayer(layer); var latlngs = data.layer.getLatLngs()[0]; var roof = new Roof(); if (this.roof != null) { roof.roofId = this.roof.roofId; } roof.setPointsFromList(latlngs); roof.calculateOrientation(this); this.roof = roof; this.drawRoof(); }; /** * Berechnet die Effizienz aller dargestellten Panels. Zunächst werden alle Panels, die im aktuellen Dach liegen ermittelt. * Sollten Sich nicht alle Panels im Dach befinden wir der Benutzer darauf aufmerksam gemacht. * Außerdem wird dem Benutzer signalisiert, falls keine Einstrahlungswerte vorliegen, bspw. beim selbst eingezeichnten Dach. * Wenn der Nutzer aktuell gar kein Dach abgebildet hat, wenn zum Beispiel keine Adresse eingegeben wurde, * oder kein Dach gezeichnet wurde, wird dem Benutzer dies ebenfalls mitgeteilt. */ Controller.prototype.getPanelEffiency = function () { if (this.roof !== null) { var arr = []; var checkedPanels = 0; for (var i = 0; i &lt; this.viewMap.moveablePolygons.length; i++) { var currentModel = this.viewMap.moveablePolygons[i].model; if (currentModel.constructor === PanelString) { var panelsInRoof = 0; for (var j = 0; j &lt; currentModel.size(); j++) { var currentPanel = currentModel.get(j); if (this.roof.getBestRoofPart(this).panelInRoof(currentPanel)) { arr.push({ width: currentPanel.width, height: currentPanel.height, pitch: currentPanel.pitch, orientation: currentPanel.orientation }); panelsInRoof++; } if (panelsInRoof === currentModel.size()) { this.viewMap.moveablePolygons[i].setStyle({fillColor: &quot;#3388ff&quot;}); } else { this.viewMap.moveablePolygons[i].setStyle({fillColor: &quot;#FF0000&quot;}); } checkedPanels++; } } } var efficiency = evaluateEfficiency(arr, this.roof.getBestRoofPart(this).global); if (checkedPanels == arr.length) { this.showEfficiency(efficiency); } else if (this.roof.getBestRoofPart(this).global === 0) { this.showEfficiency(efficiency, &quot;Für das von Ihnen ausgewählte Dach liegen keine Einstrahlungswerte vor.&quot;); } else { this.showEfficiency(efficiency, &quot;Es konnten nicht alle Solarzellen berechnet werden. Bitte überprüfen Sie die Platzierung.&quot;); } } else { this.showEfficiency(null, &quot;Bitte geben Sie Ihre Adresse ein, oder zeichnen Sie ein eigenes Dach.&quot;); } }; /** * Verarbeitet die in getPanelEfficiency ermittelten Daten * @see getPanelEfficiency * @param {object} efficiency Containerobjekt mit den Daten, die dargestellt werden sollen. Objekt muss Nennleistung, KW pro Jahr, Anzahl und Fläche enthalten. * @param {string} warningMessage Warnung, die ausgeben werden soll. */ Controller.prototype.showEfficiency = function (efficiency, warningMessage) { var nominal = 0; var perYear = 0; var counter = 0; var area = 0; if (efficiency !== null) { nominal += efficiency.nominal; perYear += efficiency.perYear; counter += efficiency.counter; area += efficiency.area; } this.efficiencyDisplay.setPanelCounter(counter); this.efficiencyDisplay.setPanelArea(area); this.efficiencyDisplay.setPanelNominal(nominal); this.efficiencyDisplay.setPerYear(perYear); if (warningMessage === undefined) { this.efficiencyDisplay.hideWarning(); } else { this.efficiencyDisplay.showWarning(warningMessage); } }; /* Callbackfunktionen */ /** * Callbackfunktion, der den Datenbankserver für den Controller deaktiviert. * @callback errorFunction */ function callbackDisableServer() { if (controller !== undefined) { controller.disableServer(); } } /** * Callbackfunktion, der dem Benutzer eine CookieID zuteilt. * @param {object} data Enthält eine gültige CookieID und ein gültiges Ablaufdatum, die vom Datenbankserver ermittelt wurde. * @callback postCookie */ function callbackCreateCookie(data) { if (controller !== undefined) { if (navigator.cookieEnabled) { controller.createUserCookie(data.cookie_id, data.ablaufdatum); } else { alert(&quot;Bitte erlauben Sie die Nutzung von Cookie auf dieser Internetseite, um alle Funktionalitäten nutzen zu können&quot;); } } } /** * Callbackfunktion, die den Inhalt eines vom Datenbankserver empfangenen Cookies verarbeitet. * Im Cookie enthalten sind die Liste aller Panels, die der Nutzer angelegt hat und auch das von Ihm zuletzt aufgerufene Dach. * @param {object} data Enthält JSON-Objekt mit alle vom Server erhaltenen Daten, die dem Cookie zugeordnert sind. * @callback getCookie */ function callbackEvaluateCookie(data) { if (controller === undefined) { return; } if (data.cookie_id === -1) { controller.deleteUserCooke(); } else { data.solarpanelList.forEach(createPanels); if (data.modelDach !== null) { var roof = new Roof(); roof.roofId = data.modelDach.dach_id; roof.global = data.modelDach.global; roof.pv = data.modelDach.pv; roof.st = data.modelDach.st; roof.gid = data.modelDach.gid; var arr = []; data.modelDach.the_geom.forEach(getCoords); function getCoords(element) { arr.push(L.latLng(element.latitude, element.longitude)); } roof.setPointsFromList(arr); roof.calculateOrientation(controller); controller.roof = roof; if (roof.gid != null) { controller.getRoofPartsFromServer(); } else { controller.drawRoof(); } } function createPanels(list) { var panelstring; for (var i = 0; i &lt; list.length; i++) { var panel = new Panel(); var listItem = list[i]; panel.setPointsFromList(listItem.the_geom); panel.pitch = listItem.neigung; panel.orientation = listItem.ausrichtung; panel.id = listItem.panel_id; panel.width = listItem.breite; panel.height = listItem.laenge; panel.frameWidth = listItem.rahmenbreite; panel.align(controller); if (i === 0) { panelstring = new PanelString(controller, panel); } else { controller.appendModel(panelstring, panel); } } console.log(panelstring.masterPanel.orientation); controller.viewMap.addMultiPolygon(panelstring); controller.viewMap.selectedPolygon.transform._orientation = -(panelstring.masterPanel.orientation - 360); } } } /** * Callbackfunktion, die ein vom Server empfangenes Dach verarbeitet. * @param {Roof} data JSON-Objekt, welches die Datenfelder eines Roof-Objekts enthält. * @callback getRoof */ function callbackGetRoof(data) { if (controller !== undefined) { var roof = new Roof(); roof.gid = data.gid; roof.pv = data.pv; roof.st = data.st; var arr = []; if (data.the_geom === undefined) { controller.showCanNotFoundAddressError(); return; } else { controller.removeAddressError(); } data.the_geom.forEach(getCoords); function getCoords(element) { arr.push(L.latLng(element.latitude, element.longitude)); } roof.setPointsFromList(arr); roof.calculateOrientation(controller); controller.roof = roof; controller.getRoofPartsFromServer(); } } /** * Callbackfunktion, die alle vom Server empfangenen Dachteile verarbeitet. * @param {Roof[]} data JSON-Objekte. welche die Datenfelder von Roof-Objekten enthalten. * @callback getRoofParts */ function callbackGetRoofParts(data) { if (controller !== undefined) { for (var i = 0; i &lt; data.length; i++) { var arr = []; var roof = new Roof(); roof.pv = data[i].pv; roof.st = data[i].st; roof.global = data[i].global; roof.tilt = data[i].tilt; data[i].the_geom.forEach(getCoords); function getCoords(element) { arr.push(L.latLng(element.latitude, element.longitude)); } roof.setPointsFromList(arr); controller.roof.addPart(roof); } controller.drawRoof(); } } × Search results Close "},"Handler_CookieHandler.js.html":{"id":"Handler_CookieHandler.js.html","title":"Source: Handler/CookieHandler.js","body":" DocStrap Classes ControllerCookieHandlerEfficiencyDisplayMapMatrixPanelPanelStringRoofServerHandlerToolbar Global BEST_PVcalcNextPointcontrollerconvexHullCOOKIENAMEDAYS_TILL_COOKIE_EXPIREDEFAULT_ZOOMefficiencyTableevaluateEfficiencyHOSTINIT_LOCATIONinitAutocompletematrixSERVER_URL Source: Handler/CookieHandler.js /** * Konstruiert ein CookieHandler-Objekt, dass Cookies vom Benutzer lesen, schreiben und löschen kann. * @class * @constructor * @param {string} name Der Name des Cookies, der gelesen, geschrieben oder gelöscht werden soll. * @property {string} name Der gespeicherte Cookie-Name. */ function CookieHandler(name) { this.name = name; } /** * Erstellt einen Cookie mit dem Wert und Ablaufdatum. * @param {*}value Der Wert, der beim Nutzer geschrieben werden soll. Der Wert wird als String konvertiert (...&quot; &quot; + value + &quot; &quot;...). * Somit ist grundsätzlich jeder Datentyp möglich, jedoch ist es sinnvoller nummerische Werte oder Strings statt Objekte zu nutzen. * @param {number} dueDate Ablaufdatum als UNIX-Zeitstempel. Negative Werte führen dazu, dass der Cookie vom Browser gelöscht wird. */ CookieHandler.prototype.createCookie = function (value, dueDate) { if (dueDate) { var date = new Date(); date.setTime(dueDate); var expires = &quot;; expires=&quot; + date.toGMTString(); } else var expires = &quot;&quot;; document.cookie = this.name + &quot;=&quot; + value + expires; }; /** * Liest einen Cookie vom Benutzer, der Cookie wird anhand des im CookieHandler gespeicherten Namen identifiziert. * @returns {string|null} Wenn ein Cookie mit dem gespeicherten Namen vorhanden ist wird der gespeicherte Wert zurückgegeben. * Wenn kein Cookie mit dem Namen gefunden wird, wird &quot;null&quot; zurückgegebeben. */ CookieHandler.prototype.readCookie = function () { var nameEQ = this.name + &quot;=&quot;; var ca = document.cookie.split(';'); for (var i = 0; i &lt; ca.length; i++) { var c = ca[i]; while (c.charAt(0) == ' ') c = c.substring(1, c.length); if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length); } return null; }; /** * Löscht ein existierenden Cookie. */ CookieHandler.prototype.eraseCookie = function () { this.createCookie(&quot;&quot;, -1); }; × Search results Close "},"View_Map.js.html":{"id":"View_Map.js.html","title":"Source: View/Map.js","body":" DocStrap Classes ControllerCookieHandlerEfficiencyDisplayMapMatrixPanelPanelStringRoofServerHandlerToolbar Global BEST_PVcalcNextPointcontrollerconvexHullCOOKIENAMEDAYS_TILL_COOKIE_EXPIREDEFAULT_ZOOMefficiencyTableevaluateEfficiencyHOSTINIT_LOCATIONinitAutocompletematrixSERVER_URL Source: View/Map.js /** * Gibt die Ort an, der beim Laden der Seite initial angezeigt wird. * Gibt die Lokation, in Längen-, Breitengrad, an, die beim Laden der Seite als erstes angezeigt wird. * * @constant * @type {number[]} */ const INIT_LOCATION = [52.520645, 13.40977]; //Koordinaten in Berlin /** * Gibt an mit welcher Zoomstufe die Karte bei der Initialisierung geladen werden soll. * * @constant * @type {number} Standardzoomstufe */ const DEFAULT_ZOOM = 20; /** * Konstruktor des Map-Objektes. * Das Map-Objekt ist eine Containerklasse zur Darstellung von Karten der Kartenprovider GoogleMaps und Openstreetmap. * Darüberhinaus das Objekt der Visualisierung von beweglichen und unbeweglichen Polygonen. * @class * @constructor * @property {L.map} map Karte die dargestellt wird. * @property {L.tileLayer|L.gridLayer.googleMutant} mapProvider Layer der Karte die dargestellt wird. * @property {Controller} controller Der mit der Karte assoziierte Controller. * @property {L.polygon[]} moveablePolygons Liste aller beweglichen Polygonen. * @property {L.polygon[]} nonMoveablePolygon Liste aller unbeweglicher Polygone. * @property {L.polygon} selectedPolygon Aktuell ausgewähltes Polygon. * @property {L.d3SvgOverlay} d3Overlay Layer zur Berechnung von Koordinaten. * @property {L.LayerGroup} handlerGroup Layer mit beweglichen Polygonen. */ function Map() { this.map = null; this.mapProvider = null; this.controller = null; this.moveablePolygons = []; this.nonMovablePolygon = []; this.selectedPolygon = null; this.d3Overlay = null; this.handlerGroup = null; } /** * Initialisierung der Karte, hier werden die Buttons mit Funktionen der Karte verknüpft und die Karte vom Kartenprovider geladen. */ Map.prototype.init = function () { this.map = L.map('map', {drawControl: false, editable: true}).setView(INIT_LOCATION, DEFAULT_ZOOM); this.showGoogle(); this.d3Overlay = L.d3SvgOverlay(function (selection, projection) { this.projection = projection; }); this.d3Overlay.addTo(this.map); var self = this; // Roof $(&quot;#drawRoof&quot;).on('click', function () { var polygonDrawer = new L.Draw.Polygon(self.map); polygonDrawer.enable(); }); this.map.on(L.Draw.Event.CREATED, function (data) { controller.createRoof(data); }); // Add Clicklistener $('#googleMap').on('click', function () { self.showGoogle() }); $('#openstreetMap').on('click', function () { self.showOpenstreet() }); }; /** * Es wird angegeben, welches Polygon Objekt ausgewählt wurde. * Hierzu wird noch zusätzlich die {@link Controller#connectModelWithToolbar} aktiviert, * um Einstellungen für die das selektiere Polygon durchzuführen. * * @param {L.polygon} selectedPolygon - Ausgewähltes Polygon-Objekt. */ Map.prototype.selectPolygon = function (selectedPolygon) { this.selectedPolygon = selectedPolygon; this.controller.connectModelWithToolbar(selectedPolygon); }; /** * Hier wird ein bewegliches Polygon als Multipolygon angelegt. * Dies wird mit einem Clicklistener verknüpft, außerdem werden Handler für die Rotation, Skalierung und Drag-Funktionalität eingerichtet. * Das Polygon wird auf der Karte dargestellt und in die Liste der beweglichen Polygone eingefügt. * * @param {Panel|PanelString} model Das Model, dass mit dem Polygon assoziert wird. Die Geodaten werden vom Controller ermittelt {link Controller#getGeoJSON}. * @return {L.polygon} Das angelegte Polygon. */ Map.prototype.addMultiPolygon = function (model) { var self = this; this.handlerGroup = this.handlerGroup || new L.LayerGroup().addTo(this.map); this.selectedPolygon = L.polygon(self.controller.getGeoJSON(model), { color : &quot;#FFF&quot;, fillColor: '#FF0', draggable: true, transform: true, opacity : 0.5, weight : model.getFrameWidth(), lineJoin : &quot;miter&quot; }).addTo(this.handlerGroup); this.selectedPolygon.model = model; this.selectedPolygon.transform.enable({ rotation: true, scaling: false, resize: true }); var orientation = model.masterPanel.orientation.toFixed(0) || 0; this.selectedPolygon.transform.setStartOrientation(orientation); this.selectedPolygon.on('click', function () { self.selectPolygon(this); }); // Drag &amp; Drop Events this.selectedPolygon.on('dragstart', function (d) { self.selectPolygon(this) }).on('dragend', function (d) { self.controller.updateModel(self.selectedPolygon, d.target._latlngs); }); // Rotation Events this.selectedPolygon.on('rotatestart', function (d) { self.selectPolygon(this) }).on('rotate', function (d) { if (self.controller.toolbar != null) self.controller.toolbar.setOrientation(d.orientation); }).on('rotateend', function (d) { self.controller.updateModel(self.selectedPolygon, d.target._latlngs, d.orientation); }); // Resize Events var lastDistance = 0; var moveDirection = 1; // left: -1, right: 1 this.selectedPolygon.on('resizestart', function (d) { self.selectPolygon(this); }).on('resize', function (d) { var startCoord = this._latlngs[0][0]; var endCoord = this._latlngs[0][1]; var distance = startCoord.distanceTo(endCoord); var currentDistance = parseInt((d.distance / distance)); moveDirection = (currentDistance &lt; lastDistance) ? -1 : 1; var isAddOrRemoveBorderExceeded = ( (currentDistance &gt;= 2 &amp;&amp; moveDirection == 1 || currentDistance &gt;= 1 &amp;&amp; moveDirection == -1) &amp;&amp; lastDistance != currentDistance ); if (isAddOrRemoveBorderExceeded) { if (currentDistance &gt; lastDistance) { self.controller.appendModel(self.selectedPolygon.model); } else { self.controller.removeModel(self.selectedPolygon.model); } self.selectedPolygon.setLatLngs(self.controller.getGeoJSON(model)); lastDistance = currentDistance } }); this.moveablePolygons.push(this.selectedPolygon); return this.selectedPolygon; }; /** * Hier wird ein nicht bewegliches Polygon angelegt. Das Polygon wird in den Hintergrund verschoben, um bewegliche Polygone nicht einzuschränken. * Das Polygon wird in die Liste der unbeweglichen Polygone eingefügt. * @param {Roof} model - Darzustellendes unbewegliches Model, welches mit dem Polygon verknüpft wird. */ Map.prototype.addNonMovable = function (model) { var polygon = model.getAsPolygon(); polygon.addTo(this.map); polygon.bringToBack(); this.nonMovablePolygon.push(polygon); }; /** * Entfernt alle nicht beweglichen Polygone von der Karte und aus der Liste der nicht beweglichen Polygone. */ Map.prototype.removeAllNonMoveable = function () { while (this.nonMovablePolygon.length !== 0) { this.map.removeLayer(this.nonMovablePolygon.pop()); } }; /** * Die Karte wird auf die übergebenen Koordinaten, mit der Standardzoomstufe, zentriert. * * @param {number} lat - Längengrad (latitude) * @param {number} lng - Breitengrad (longitude) */ Map.prototype.setFocus = function (lat, lng) { this.map.setView(new L.LatLng(lat, lng), DEFAULT_ZOOM); }; /* Konvertierung LatLng zu Punkt und umgekehrt */ /** * Konvertiert einen Punkt auf der Karte zu einem Längen- und Breitengrad. * * @param {L.point} point - Punkt auf der Karte. * @returns {L.latLng} Längen-, Breitengrad. */ Map.prototype.layerPointToLatLng = function (point) { return this.d3Overlay.projection.layerPointToLatLng(point); }; /** * Konvertiert Längen- und Breitengrad zu dem entsprechendem Punkt (X/Y-Koordinaten). * * @param {L.latLng} latLng - Koordinaten als Längen-, Breitengrad * @returns {L.point} Punkt auf der Karte */ Map.prototype.latLngToLayerPoint = function (latLng) { return this.d3Overlay.projection.latLngToLayerPoint(latLng); }; /** * Konvertiert Längen- und Breitengrad zu dem entsprechendem Punkt (X/Y-Koordinaten). * Unter Berücksichtigung der Größe des entsprechenden HTML-Elementes. * * @param {L.point} point - Punkt auf der Karte * @returns {L.latLng} Längen-, Breitengrad */ Map.prototype.containerPointToLatLng = function (point) { return this.map.containerPointToLatLng(point); }; /** * Zeigt als Kartenlayer Google Maps an */ Map.prototype.showGoogle = function () { var layer = L.gridLayer.googleMutant({ type: 'satellite', maxZoom: 20 }); this.changeMapProvider(layer); }; /** * Zeigt als Kartenlayer Openstreetmap an */ Map.prototype.showOpenstreet = function () { var mapLink = '&lt;a href=&quot;http://openstreetmap.org&quot;&gt;OpenStreetMap&lt;/a&gt;'; var layer = L.tileLayer( 'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&amp;copy; ' + mapLink + ' Contributors', maxZoom: 18 }); this.changeMapProvider(layer); }; /** * Es wird der übergebe Layer als Kartenlayer angezeigt und der vorher ausgewählte wird entfernt. * * @param {L.tileLayer|L.gridLayer.googleMutant} layer - Kartenlayer */ Map.prototype.changeMapProvider = function (layer) { if (this.mapProvider) { this.map.removeLayer(this.mapProvider); } this.mapProvider = layer; this.map.addLayer(this.mapProvider); }; /** * Es wird das ausgewählte Panel von der Karte und aus der Liste der beweglichen Polygone entfernt. * */ Map.prototype.removeSelected = function () { this.selectedPolygon.transform.disable(); this.map.removeLayer(this.selectedPolygon); for(var i = 0; i &lt; this.moveablePolygons.length; i++) { if(this.selectedPolygon.model.equals(this.moveablePolygons[i].model)) { this.moveablePolygons.splice(i, 1); return; } } }; × Search results Close "},"View_EfficiencyDisplay.js.html":{"id":"View_EfficiencyDisplay.js.html","title":"Source: View/EfficiencyDisplay.js","body":" DocStrap Classes ControllerCookieHandlerEfficiencyDisplayMapMatrixPanelPanelStringRoofServerHandlerToolbar Global BEST_PVcalcNextPointcontrollerconvexHullCOOKIENAMEDAYS_TILL_COOKIE_EXPIREDEFAULT_ZOOMefficiencyTableevaluateEfficiencyHOSTINIT_LOCATIONinitAutocompletematrixSERVER_URL Source: View/EfficiencyDisplay.js var EfficiencyDisplay = (function () { /** * Repräsentiert die Anzeige für die Effizienz * @class * @constructor EfficiencyDisplay * @property {jQuery} panelCounter Html Element für die Anzeige der Panelanzahl * @property {jQuery} panelArea Html Element für die Anzeige der Quatratmeter * @property {jQuery} panelNominal Html Element für die Anzeige der Nennleistung * @property {jQuery} panelPerYear Html Element für die Anzeige den Stromertrag pro Jahr * @property {jQuery} warningContainer Html Element für die Warnung * @property {jQuery} warningMessage Html Element für die Anzeige der Warnung * @property {object} panel Panel hält die Daten für die Anzeige * @property {number} panel.counter Hält die Anzahl der Panels * @property {number} panel.area Hält die Anzahl der Panels * @property {number} panel.nominal Hält die Anzahl der Panels * @property {number} panel.perYear Hält die Anzahl der Panels */ function EfficiencyDisplay() { this.panelCounter = $('#panel_counter'); this.panelArea = $('#panel_area'); this.panelNominal = $('#panel_nominal'); this.panelPerYear = $('#panel_per_year'); this.warningContainer = $('#panel_efficiency_error'); this.warningMessage = $('#panel_efficiency_error').find('.warningMessage'); this.panel = { counter: 0, area: 0, nominal: 0, perYear: 0 } } /** * Gibt die Anzahl der Panels zurück * @memberOf EfficiencyDisplay * @return {number} Anzahl der Panels */ EfficiencyDisplay.prototype.getPanelCounter = function () { return this.panel.counter; }; /** * Setzt die Anzahl der Panels und zeigt die an. * @memberOf EfficiencyDisplay * @param {number} counter - Anzahl der Panels */ EfficiencyDisplay.prototype.setPanelCounter = function (counter) { this.panel.counter = counter; this.panelCounter.html(counter); }; /** * Gibt die gesetzten Quadratmeter des Panelstrings wieder * @memberOf EfficiencyDisplay * @returns {number} Quadratmeter */ EfficiencyDisplay.prototype.getPanelArea = function () { return this.panel.area; }; /** * Setzt die Quadratmeter der Panelstring Fläche und zeigt diese an * @memberOf EfficiencyDisplay * @param {number} squareMeter - Quadratmeter */ EfficiencyDisplay.prototype.setPanelArea = function (squareMeter) { this.panel.area = squareMeter; this.panelArea.html(squareMeter + &quot; m²&quot;); }; /** * Gibt die gesetzte Nennleistung zurück * @memberOf EfficiencyDisplay * @returns {number} Nennleistung */ EfficiencyDisplay.prototype.getPanelNominal = function () { return this.panel.nominal; }; /** * Setzt die Nennleistung und zeigt diese an * @memberOf EfficiencyDisplay * @param {number} nominal - Nennleistung */ EfficiencyDisplay.prototype.setPanelNominal = function (nominal) { this.panel.nominal = nominal; this.panelNominal.html(nominal + &quot; kWh&quot;); }; /** * Gibt den gesetzten Stromertrag zurück * @memberOf EfficiencyDisplay * @returns {number} Stromertrag */ EfficiencyDisplay.prototype.getPerYear = function () { return this.panel.perYear }; /** * Setzt den Stromertrag pro Jahr und zeigt diesen an * @memberOf EfficiencyDisplay * @param {number} perYear - Stromertrag */ EfficiencyDisplay.prototype.setPerYear = function (perYear) { this.panel.perYear = perYear; this.panelPerYear.html(perYear + &quot; kWH/Jahr&quot;) }; /** * Zeigt den Warnhinweis, mit der übergeben Warnung, an. * @memberOf EfficiencyDisplay * @param {string} warning - Warnung */ EfficiencyDisplay.prototype.showWarning = function (warning) { this.warningContainer.removeClass('hidden'); this.warningMessage.html(warning); }; /** * Verbirgt den Warnhinweis * @memberOf EfficiencyDisplay */ EfficiencyDisplay.prototype.hideWarning = function () { this.warningContainer.addClass('hidden'); }; return EfficiencyDisplay; }()); × Search results Close "},"Utility_PanelEfficiency.js.html":{"id":"Utility_PanelEfficiency.js.html","title":"Source: Utility/PanelEfficiency.js","body":" DocStrap Classes ControllerCookieHandlerEfficiencyDisplayMapMatrixPanelPanelStringRoofServerHandlerToolbar Global BEST_PVcalcNextPointcontrollerconvexHullCOOKIENAMEDAYS_TILL_COOKIE_EXPIREDEFAULT_ZOOMefficiencyTableevaluateEfficiencyHOSTINIT_LOCATIONinitAutocompletematrixSERVER_URL Source: Utility/PanelEfficiency.js /** * LookUp-Tabelle mit Effektivitätsgrad mit entsprechender Neigung und Nord-Süd-Ausrichtung. * @see {@link https://www.photovoltaik-web.de/photovoltaik/dacheignung/dachneigung} * @type {number[][]} Matrix 10x19, Neigung von 0-90 Grad in Zehnerschritten und der Nord-Süd-Ausrichtung 0-180 Grad in Zehnerschritten. */ var efficiencyTable = [ [87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87], [93, 93, 93, 92, 92, 91, 90, 89, 88, 86, 85, 84, 83, 81, 81, 80, 79, 79, 79], [97, 97, 97, 96, 95, 93, 91, 89, 87, 85, 82, 80, 77, 75, 73, 71, 70, 70, 70], [100, 99, 99, 97, 96, 94, 91, 88, 85, 82, 79, 75, 72, 69, 66, 64, 62, 61, 61], [100, 99, 99, 97, 95, 93, 90, 86, 83, 79, 75, 71, 67, 63, 59, 56, 54, 52, 52], [98, 97, 96, 95, 93, 90, 87, 83, 79, 75, 70, 66, 61, 56, 52, 48, 45, 44, 43], [94, 93, 92, 91, 88, 85, 82, 78, 74, 70, 65, 60, 55, 50, 46, 41, 38, 36, 35], [88, 87, 86, 85, 82, 79, 76, 72, 68, 70, 58, 54, 49, 44, 39, 35, 32, 29, 28], [80, 79, 78, 77, 75, 72, 68, 65, 61, 56, 51, 47, 42, 37, 33, 29, 26, 24, 23], [69, 69, 69, 67, 65, 63, 60, 56, 53, 48, 44, 40, 35, 31, 27, 24, 21, 19, 18] ]; /** * @typedef {Object} Effizienz * @property {number} nominal - Nennleistung * @property {number} perYear - Leistung pro Jahr * @property {number} counter - Anzahl der Panels * @property {number} area - Fläche */ /** * @typedef panels * @property {number} height - Höhe * @property {number} width - Breite * @property {number} pitch - Neigung * @property {number} orientation - Orientierung */ /** * Die Effizienz eines Panels wird unter Berücksichtigung der Einstrahlwerte berechnet. * Zur Berechnung wird eine Nennleistung von 1000 kWh und eine Effektivität von 15 % genutzt. * Hierbei wird eine Südausrichtung mit 0 Grad angegeben und eine Nordausrichtung mit 180 Grad, während Westen und Osten jeweils zueinander identisch sind. * * @param {panels[]} panels - Liste mit modifizierten Panelobjekten der Form: {@link panels} * @param {number} global - Einstrahlungswerte der Panels an der entsprechenden Position. * @return {Effizienz} Gibt die Effizienz im JSON Format zurück. */ function evaluateEfficiency (panels, global){ var panelarea = 0; var nominaloutput = 1000; var efficiency = 0.15; var KWPerYear = 0; var totalPanelarea = 0; var usedPanels = 0; for (var i in panels) { if(panels[i].pitch &lt;= 90) { orientation = panels[i].orientation; if(orientation &lt; 90) { orientation += 90; } else if(orientation &gt; 180 &amp;&amp; orientation &lt; 270) { orientation-=180; } else if(orientation &gt;= 270) { orientation-=270; } orientation = Math.round(orientation / 10); pitch = Math.round(panels[i].pitch / 10); panelarea = (panels[i].height * panels[i].width); totalPanelarea+=panelarea; KWPerYear += (nominaloutput * efficiency * panelarea * global) / 1000 * (efficiencyTable[pitch][orientation] / 100); usedPanels++; } } return { nominal: nominaloutput, perYear: parseFloat(KWPerYear.toFixed(2)), counter: usedPanels, area: totalPanelarea }; } × Search results Close "},"Utility_Matrix.js.html":{"id":"Utility_Matrix.js.html","title":"Source: Utility/Matrix.js","body":" DocStrap Classes ControllerCookieHandlerEfficiencyDisplayMapMatrixPanelPanelStringRoofServerHandlerToolbar Global BEST_PVcalcNextPointcontrollerconvexHullCOOKIENAMEDAYS_TILL_COOKIE_EXPIREDEFAULT_ZOOMefficiencyTableevaluateEfficiencyHOSTINIT_LOCATIONinitAutocompletematrixSERVER_URL Source: Utility/Matrix.js /** * Konstruiert ein Matrix-Objekt. * Das Matrix-Objekt ist eine Hilfsklasse, die Rotationsmatrizen zur Rotation entlang der X-/Z-Achse liefert. * Bei den Matrizen handelt es sich um 3x3-Matrizen. * Außerdem stellt das Objekt die Funktionalität zur Verfügung eine 3x3 Matrix mit einem Vektor (x,y,z) zu multiplizieren. * @class * @constructor * @property {number} lastOrientation Der zuletzt berechnte Rotationswinkel der Z-Rotationsmatrix. * @property {number[][]} lastOrientationMatrix Die der zuletzt berechneten Z-Rotationsmatrix in Relation zum zuletzt berechnten Rotationswinkel. * @property {number} lastPitch Der zuletzt berechnte Rotationswinkel der X-Rotationsmatrix. * @property {number[][]} lastPitchMatrix Die der zuletzt berechneten X-Rotationsmatrix in Relation zum zuletzt berechneten Rotationswinkel. */ function Matrix() { this.lastOrientation = null; this.lastOrientationMatrix = null; this.lastPitch = null; this.lastPitchMatrix = null; } /** * Berechnet die Rotationsmatrix zur Rotation entlang der Z-Achse. * Berechnungen werden gespeichert um ggf. identische Berechnungen, die nacheinander durchgeführt werden, zu verhindern. * @param {number} orientation Der Drehwinkel der zur Berechnung der Matrix genutzt wird. * @returns {number[][]|null} Die Rotationsmatrix 3x3 die berechnet oder aus dem Speicher gelesen wird. * Gibt die zuletzt gespeicherte Matrix zurück wenn &quot;null&quot; übergeben wird. */ Matrix.prototype.calculateOrientationMatrix = function (orientation) { if (this.lastOrientation === orientation) { return this.lastOrientationMatrix; } this.lastOrientation = orientation; this.lastOrientationMatrix = [ [Math.cos(orientation * Math.PI / 180), -Math.sin(orientation * Math.PI / 180), 0], [Math.sin(orientation * Math.PI / 180), Math.cos(orientation * Math.PI / 180), 0], [0, 0, 1] ]; return this.lastOrientationMatrix; }; /** * Berechnet die Rotationsmatrix zur Rotation entlang der X-Achse. * Berechnungen werden gespeichert um ggf. identische Berechnungen, die nacheinander durchgeführt werden, zu verhindern. * @param {number} pitch Der Drehwinkel der zur Berechnung der Matrix genutzt wird. * @returns {number[][]|null} Die Rotationsmatrix 3x3 die berechnet oder aus dem Speicher gelesen wird. * Gibt die zuletzt gespeicherte Matrix zurück wenn &quot;null&quot; übergeben wird. */ Matrix.prototype.calculatePitchMatrix = function (pitch) { if (this.lastPitch === pitch) { return this.lastPitchMatrix; } this.lastPitch = pitch; this.lastPitchMatrix = [ [1, 0, 0], [0, Math.cos(pitch * Math.PI / 180), -Math.sin(pitch * Math.PI / 180)], [0, Math.sin(pitch * Math.PI / 180), Math.cos(pitch * Math.PI / 180)] ]; return this.lastPitchMatrix; }; /** * Multipliziert eine 3x3 Matrix mit einem Vektor (x,y,z). * @param {number[][]} matrix Matrix der Form 3x3. * @param {number[]} vector Vektor aus drei Komponenten. * Bei Vektoren, die aus mehr Komponenten bestehen werden die weiteren Komponenten ignoriert und es wird so verfahren, * als ob der Vektor nur drei Komponenten hätte. * @returns {number[]} Das Ergebnis der Multiplikation, ein Vektor aus drei Komponenten. */ Matrix.prototype.matrixMultiplyVector = function (matrix, vector) { var newVector = [ matrix[0][0] * vector[0] + matrix[0][1] * vector[1] + matrix[0][2] * vector[2], matrix[1][0] * vector[0] + matrix[1][1] * vector[1] + matrix[1][2] * vector[2], matrix[2][0] * vector[0] + matrix[2][1] * vector[1] + matrix[2][2] * vector[2] ]; return newVector; }; × Search results Close "},"Model_PanelString.js.html":{"id":"Model_PanelString.js.html","title":"Source: Model/PanelString.js","body":" DocStrap Classes ControllerCookieHandlerEfficiencyDisplayMapMatrixPanelPanelStringRoofServerHandlerToolbar Global BEST_PVcalcNextPointcontrollerconvexHullCOOKIENAMEDAYS_TILL_COOKIE_EXPIREDEFAULT_ZOOMefficiencyTableevaluateEfficiencyHOSTINIT_LOCATIONinitAutocompletematrixSERVER_URL Source: Model/PanelString.js /** * @class PanelString * * @static {number} UNIFIER - Statischer Zähler zur eindeutigen Identifizierung eines PanelString-Objektes während einer Session. * @property {number} unifier - Dem PanelString zugeordneter Zähler zur eindeutigen Identifizierung * @property {Controller} controller - Hauptcontroller um die richtige Darstellung auf der Karte zu gewährleisten. * @property {Panel} masterPanel - Hauptpanel an dem sich die Panels des PanelStrings ausrichten. * @property {Panel[]} panels - Panels, die an den Hauptpanel angehängt wurden. */ var PanelString = (function () { /** * Erstellt ein PanelString Object. Das PanelString Object verwaltet die korrekte Aneinanderreihung der Panels. * Die Haupteinstellungen werden am übergeben MasterPanel getätigt und anschließend an die angehängten Panels weitergegeben. * Beim Anlegen eines neuen PanelStrings wird die statische UNIFIER-Variable inkrementiert. * @memberOf PanelString * * @param {Controller} controller - Der Hauptcontroller um den PanelString korrekt darzustellen. * @param {Panel} masterPanel - MasterPanel, an dem sich angehängte Panels ausrichten. */ function PanelString(controller, masterPanel) { this.controller = controller; this.masterPanel = masterPanel; this.panels = []; this.unifier = PanelString.UNIFIER++; } /** * Es wird ein erstelltes Panel übergeben, welches anschließend die Eigenschaften des MasterPanels übernimmt. * Das angehängte Panel wird zusätzlich der Panelliste des PanelString hinzugefügt. * * @memberOf PanelString * @param {Panel} panel - Anzuhängendes Panel. */ PanelString.prototype.appendPanel = function (panel) { if (panel != undefined) { var master = this.masterPanel; panel.topLeft = master.topLeft; panel.pitch = master.pitch; panel.orientation = master.orientation; panel.frameWidth = master.frameWidth; panel.align(this.controller, master.width, master.height); this.panels.push(panel); } }; /** * Der Aufruf der Funktion wird an die Ausrichtungfunktion {@link Panel#align} des Hauptpanels weitergeleitet. * * @memberOf PanelString * @param {Controller} controller - Hauptcontroller, zur Berechnung der Ausrichtung. * @param {number} width - Breite des Panels. * @param {number} height - Höhe/Länge des Panels. */ PanelString.prototype.align = function (controller, width, height) { this.masterPanel.align(controller, width, height); }; /** * Gibt die Liste aller Längen- und Breitengrade eines PanelStrings wieder. * @memberOf PanelString * * @returns {Array} Liste aller Längen- und Breitengrade */ PanelString.prototype.getPointsAsList = function () { return this.getGeoJSON(); }; /** * Entfernt das zuletzt eingefügten Panel. Das MasterPanel kann so nicht entfernt werden. * @memberOf PanelString * * @returns {string|number} Gibt die Id des entfernten Panel zurück. * Wenn kein Panel gelöscht werden kann, wird die ID des MasterPanels zurückgegeben. */ PanelString.prototype.removePanel = function () { var removedPanelId = this.masterPanel.id; if (this.panels.length !== 0) { removedPanelId = this.panels[this.panels.length - 1].id; var removePosition = this.panels.length - 1; this.panels.splice(removePosition, 1); } return removedPanelId; }; /** * Hier wird die Orientierung des PanelString gesetzt, hierbei wird die Orientierung nur beim MasterPanel gesetzt, * um die Orientierung auf die angehängten Panele zu übertragen ist der Funktionsaufruf zur Aktualisierung der Geometrischen Eigenschaften * {@link PanelString#refreshGeometrics} notwendig. * @memberOf PanelString * * @param {number} orientation Orientierung von 0-360 Grad. */ PanelString.prototype.setOrientation = function (orientation) { var master = this.masterPanel; var o = orientation; if (o &lt; 0) { o += 360; } master.setOrientation(this.controller, o); }; /** * Der Aufruf der Funktion wird an die Setter-Funktion für die Rahmenbreite {@link Panel#setFrameWidth} des Hauptpanels weitergeleitet. * @memberOf PanelString * @param {number} width - Rahmenbreite des Panels. */ PanelString.prototype.setFrameWidth = function (width) { this.masterPanel.setFrameWidth(this.controller, width); }; /** * Der Aufruf der Funktion wird an die Setter-Funktion für die Neigung{@link Panel#setPitch} des Hauptpanels weitergeleitet. * * @memberOf PanelString * @param {number} pitch - Neigung des Panels. */ PanelString.prototype.setPitch = function (pitch) { this.masterPanel.setPitch(this.controller, pitch); }; /** * Die Position des MasterPanels wird neu gesetzt. * * @memberOf PanelString * @param {L.latLng[][]} latlngs - Längen- und Breitengrade der neuen Koordinaten. */ PanelString.prototype.setPosition = function (latlngs) { var topLeft = latlngs[0][0]; var master = this.masterPanel; master.setTopLeft(this.controller, topLeft); }; /** * Gibt die Rahmenbreite in Pixel wieder. * * @memberOf PanelString * @returns {number} Gibt die Rahmenbreite in Pixel wieder */ PanelString.prototype.getFrameWidth = function () { return this.masterPanel.getFrameWidthInPixel(this.controller); }; /** *Ermittelt die Position, wo das anliegende Panel als nächstes angesetzt wird. * @memberOf PanelString * @private * @param {Panel} panel - Das Panel, dessen Punkt den Anhängepunkt darstellt. * @returns {L.latLng} Die nordöstlichste Ecke des Quellpanels. */ PanelString.prototype.getNextPoint = function (panel) { return panel.getPointsAsList()[1]; }; /** * Aktualisiert die Position der einzelnen Panels, die Orientierung erfolgt anhand der Attribute des MasterPanels. * Die Einstellungen des MasterPanels werden an die angehängten Panels weitergegeben. * * @memberOf PanelString * @private */ PanelString.prototype.refreshGeometrics = function () { var orientation = this.masterPanel.orientation; var pitch = this.masterPanel.pitch; var nextLatLng = this.getNextPoint(this.masterPanel); var height = this.masterPanel.height; var width = this.masterPanel.width; var frameWidth = this.masterPanel.frameWidth; for (var i = 0; i &lt; this.panels.length; i++) { this.panels[i].setTopLeft(this.controller, nextLatLng); this.panels[i].setOrientation(this.controller, orientation); this.panels[i].setPitch(this.controller, pitch); this.panels[i].width = width; this.panels[i].height = height; this.panels[i].frameWidth = frameWidth; nextLatLng = this.getNextPoint(this.panels[i]); } }; /** * Gibt einen Array aller Panels mit entsprechen Längen- und Breitengraden ({@link Panel#getLatLngsAsArray}) wieder * @memberOf PanelString * * @returns {Array} Array der Längen- und Breitengraden aller Panels */ PanelString.prototype.getGeoJSON = function () { this.refreshGeometrics(); var polygonArray = []; polygonArray.push(this.masterPanel.getLatLngsAsArray()); for (var i = 0; i &lt; this.panels.length; i++) { polygonArray.push(this.panels[i].getLatLngsAsArray()); } return polygonArray; }; /** * Gibt das Panel entsprechenden Stelle aus. * Wobei 0 das erste Panel ist. * * @memberOf PanelString * @param {number} index - Index des gewünschten Panels. * @returns {Panel|null} Panel an der übergebenen Position. Bei ungültigen Indices wird null zurückgegeben. */ PanelString.prototype.get = function (index) { if (index &lt; 0 || index &gt; this.size()) { return null; } if (index === 0) { return this.masterPanel; } else { return this.panels[index - 1]; } }; /** * Gibt die Anzahl der Panels im PanelString zurück. * * @memberOf PanelString * @returns {number} Anzahl der Panels. */ PanelString.prototype.size = function () { return this.panels.length + 1; }; /** * Gibt die ID des MasterPanels zurück. * * @memberOf PanelString * @returns {number} ID des MasterPanels */ PanelString.prototype.getId = function () { return this.masterPanel.getId(); }; /** * Vergleicht aktuelles PanelString mit dem übergeben PanelString. * * @memberOf PanelString * @param {PanelString} panelstring - Ein PanelString. * @returns {boolean} Gibt an ob der übergebene PanelString der selbe PanelString ist wie dieser. */ PanelString.prototype.equals = function (panelstring) { if (panelstring.masterPanel === undefined) { return false; } return this.getId() === panelstring.getId() &amp;&amp; this.size() === panelstring.size() &amp;&amp; this.unifier === panelstring.unifier; }; PanelString.UNIFIER = 0; return PanelString; }()); //# sourceMappingURL=PanelString.js.map × Search results Close "},"Handler_ServerHandler.js.html":{"id":"Handler_ServerHandler.js.html","title":"Source: Handler/ServerHandler.js","body":" DocStrap Classes ControllerCookieHandlerEfficiencyDisplayMapMatrixPanelPanelStringRoofServerHandlerToolbar Global BEST_PVcalcNextPointcontrollerconvexHullCOOKIENAMEDAYS_TILL_COOKIE_EXPIREDEFAULT_ZOOMefficiencyTableevaluateEfficiencyHOSTINIT_LOCATIONinitAutocompletematrixSERVER_URL Source: Handler/ServerHandler.js /** * Konstruiert ein ServerHandler-Objekt, dass die Kommunikation * mit der REST-Schnittstelle des als Parameter angegebenen Servers übernimmt. * @class * @constructor * @param {string} url Die URL des Servers mit dem kommuniziert werden soll. * @property {string} serverUrl Die URL des Servers. * @property {function} errorFunction Eine Standardfunktion, die im Fehlerfall ausgeführt wird. */ function ServerHandler(url) { this.serverURL = url; this.errorFunction = function () { console.log(&quot;Fehler beim Versuch mit dem Server zu kommunizieren&quot;); } } /** * Löst den GET-Request cookie/getCookie/, des in der URL des ServerHandlers gespeicherten Servers, aus. * Die Anfrage hat die Form &quot;URL/cookie/getCookie/id&quot; * @param {number} id Die ID, die der Serverfunktion übergeben wird. * @param {function} callback Die Funktion, die im Erfolgfall aufgerufen werden soll. Die Funktion erhält den vom Server enhaltende Response. */ ServerHandler.prototype.getCookie = function (id, callback) { var serverFunction = &quot;cookie/getCookie/&quot; + id; this._get(serverFunction, function (data) { callback(data); }); }; /** * Löst den GET-Request dach/getPredefinedRoof/ des in der URL des ServerHandlers gespeicherten Servers aus. * Die Anfrage hat die Form &quot;URL/dach/getPredefinedRoof/street/nr/citycode&quot; * @param {string} street Der Straßenname, der dem Server übergeben wird. * @param {number} nr Die Hausnummer, die dem Server übergeben wird. * @param {number} citycode Die Postleitzahl, die dem Server übergeben wird. * @param {function} callback Die Funktion, die im Erfolgfall aufgerufen werden soll. Die Funktion erhält den vom Server enhaltenen Response. */ ServerHandler.prototype.getPredefinedRoof = function (street, nr, citycode, callback) { var serverFunction = &quot;dach/getPredefinedRoof/&quot; + street + &quot;/&quot; + nr + &quot;/&quot; + citycode; this._get(serverFunction, function (data) { callback(data); }); }; /** * Löst den GET-Request dach/getRoofParts/ ,des in der URL des ServerHandlers gespeicherten Servers, aus. * Die Anfrage hat die Form &quot;URL/dach/getRoofParts/gid&quot; * @param {number} gid Die GebäudeID, die dem Server übergeben wird. * @param {function} callback Die Funktion, die im Erfolgfall aufgerufen werden soll. Die Funktion erhält den vom Server erhaltende Response. */ ServerHandler.prototype.getRoofParts = function (gid, callback) { var serverFunction = &quot;dach/getRoofParts/&quot; + gid; this._get(serverFunction, function (data) { callback(data); }); }; /** * Löst den GET-Request panel/removePanel/, des in der URL des ServerHandlers gespeicherten Servers, aus. * Die Anfrage hat die Form &quot;URL/panel/removePanel/id&quot; * @param {number} id Die PanelID, die dem Server übergeben wird. * @param {function} callback Die Funktion, die im Erfolgfall aufgerufen werden soll. Die Funktion erhält den vom Server erhaltende Response. */ ServerHandler.prototype.removePanel = function (id, callback) { var serverFunction = &quot;panel/removePanel/&quot; + id; this._get(serverFunction, function (data) { callback(data); }) }; /** * Löst den POST-Request, des in der URL des ServerHandlers gespeichtern Servers, aus. * Die Server-Funktion &quot;cookie/postCookie&quot; wird genutzt. * @param {string} json Das JSON-Objekt, als String, welches dem Server übermittelt wird. * @param {function} callback Die Funktion, die im Erfolgfall aufgerufen werden soll. Die Funktion erhält den vom Server erhaltende Response. */ ServerHandler.prototype.postCookie = function (json, callback) { this._post(json, &quot;cookie/postCookie&quot;, function (data) { callback(data); }); }; /** * Löst den POST-Request, des in der URL des ServerHandlers gespeichtern Servers, aus. * Die Server-Funktion &quot;panel/postPanel&quot; wird genutzt. * @param {string} json Das JSON-Objekt, als String, welches dem Server übermittelt wird. * @param {Panel} model Das Panel, welches im Erfolgsfall der Callbackfunktion übergeben wird. * @param {function} callback Die Funktion, die im Erfolgfall aufgerufen werden soll. * Die Funktion erhält den vom Server enhaltenen Response und das Model welches postPanel-Funktion übergeben wurde. */ ServerHandler.prototype.postPanel = function (json, model, callback) { this._post(json, &quot;panel/postPanel&quot;, function (data) { callback(data, model); }) }; /** * Löst den POST-Request, des in der URL des ServerHandlers gespeicherten Servers, aus. * Die Server-Funktion &quot;panel/updatePanel&quot; wird genutzt. * @param {string} json Das JSON-Objekt, als String, welches dem Server übermittelt wird. * @param {function} callback Die Funktion, die im Erfolgfall aufgerufen werden soll. Die Funktion erhält den vom Server enhaltenen Response. */ ServerHandler.prototype.updatePanel = function (json, callback) { this._post(json, &quot;panel/updatePanel&quot;, function (data) { callback(data); }) }; /** * Löst den POST-Request, des in der URL des ServerHandlers gespeicherten Servers, aus. * Die Server-Funktion &quot;dach/postRoof&quot; wird genutzt. * @param {string} json Das JSON-Objekt, als String, welches dem Server übermittelt wird. * @param {function} callback Die Funktion, die im Erfolgfall aufgerufen werden soll. Die Funktion erhält den vom Server enhaltenen Response. */ ServerHandler.prototype.postRoof = function (json, callback) { this._post(json, &quot;dach/postRoof&quot;, function (data) { callback(data); }) }; /** * Generalisierung aller GET-Funktionen. * Hier wird die AJAX-Anfrage durchgeführt und im Erfolgsfall die übergebene Callbackfunktion ausgelöst, * ansonsten die Error-Funktion, die im ServerHandler gespeichert ist. * @param {string} serverFunction Name/Pfad der Serverfunktion die angesprochen werden soll. * @param {function} successCallback Funktion, die als Callback im Erfolgsfall aufgerufen werden soll. * @example _get(&quot;cookie/getCookie/1&quot;, function(data) { } ); * @private */ ServerHandler.prototype._get = function (serverFunction, successCallback) { var errorFunction = this.errorFunction; $.ajax({ type: &quot;GET&quot;, dataType: &quot;json&quot;, url: this.serverURL + serverFunction, timeout: 3000 }).done(successCallback).fail(errorFunction); }; /** * Generalisieurng aller POST-Funktionen. * Hier wird die AJAX-Anfrage durchgeführt und im Erfolgsfall die übergebene Callbackfunktion ausgelöst, * ansonsten die Error-Funktion, die im ServerHandler gespeichert ist. * @param {string} objAsJson Das JSON-Objekt als String, dass dem Server übermittelt werden soll. * @param {string} serverFunction Name/Pfad der Serverfunktion die angesprochen werden soll. * @param {function} successCallback Funktion, die als Callback im Erfolgsfall aufgerufen werden soll. * @example _get(JSON-String, &quot;cookie/postCookie&quot;, function(data) { } ); * @private */ ServerHandler.prototype._post = function (objAsJson, serverFunction, successCallback) { var errorFunction = this.errorFunction; $.ajax({ crossDomain: true, type: &quot;POST&quot;, dataType: &quot;json&quot;, contentType: &quot;application/json&quot;, cors: &quot;true&quot;, url: this.serverURL + serverFunction + '/', data: objAsJson, header: { &quot;content-type&quot;: &quot;application/json&quot; } }).done(successCallback).fail(errorFunction); }; × Search results Close "},"View_Toolbar.js.html":{"id":"View_Toolbar.js.html","title":"Source: View/Toolbar.js","body":" DocStrap Classes ControllerCookieHandlerEfficiencyDisplayMapMatrixPanelPanelStringRoofServerHandlerToolbar Global BEST_PVcalcNextPointcontrollerconvexHullCOOKIENAMEDAYS_TILL_COOKIE_EXPIREDEFAULT_ZOOMefficiencyTableevaluateEfficiencyHOSTINIT_LOCATIONinitAutocompletematrixSERVER_URL Source: View/Toolbar.js /** * Die Toolbar dient dazu Einstellungen an einem {@link PanelString} oder {@link Panel} vorzunehmen. * Modifizierbar sind Breite, Länge, Ausrichtung, Neigung und Rahmenbreite. * * @param {Panel|PanelString} model - Model, welches bearbeitet werden soll. * @constructor * * @property {boolean} isPanelString - Hält die Information ob es sich hierbei um einem {@link PanelString} oder {@link Panel} handelt. * @property {Panel|PanelString} selectedModel - Ausgewähltes Modell. * @property {jQuery} toolsContainer - Das HTML-Element für die Werkzeugleiste. * @property {jQuery} toolsHeadline - HTML Element für die Überschrift * @property {jQuery} modelTilt - Slider für die Einstellung der Neigung * @property {jQuery} modelTiltValue - HTML Element für den Wert der Neigung * @property {jQuery} modelWidth - Slider für die Einstellung der Breite * @property {jQuery} modelWidthValue - HTML Element für die Anzeige der Breite * @property {jQuery} modelHeight - Slider für die EInstellung der Höhe * @property {jQuery} modelHeightValue - HTML Element für die Anzeige der Höhe * @property {jQuery} modelOrientation - Slider für die Einstellung der Orientierung * @property {jQuery} modelOrientationValue - HTML Element für die Anzeige der Orientierung * @property {jQuery} modelFrame - Slider für die Einstellung der Rahmenbreite * @property {jQuery} modelFrameValue - HTML Element für die Anzeige der Rahmenbreite * @property {jQuery} modelDelete - Button für die Löschung des Panels * @property {jQuery} moreContent - HTML Kontainer der weitere Einstellungsmöglichkeiten versteckt * @property {jQuery} showMoreButton - Button für die Klickevents von moreContent */ function Toolbar(model) { this.isPanelString = false; if (model.constructor == PanelString) { this.selectedModel = model.masterPanel; this.isPanelString = true; } else { this.selectedModel = model; } this.toolsContainer = $(&quot;#tools&quot;); this.toolsContainer.removeClass(&quot;hidden&quot;); $(&quot;#map_container&quot;).removeClass().addClass(&quot;col-sm-6&quot;); this.toolsHeadline = $(&quot;#tools_headline&quot;).find(&quot;.headline&quot;); this.modelTilt = $(&quot;#model_tilt&quot;); this.modelTiltValue = $(&quot;#model_tilt_value&quot;); this.modelWidth = $(&quot;#model_width&quot;); this.modelWidthValue = $(&quot;#model_width_value&quot;); this.modelHeight = $(&quot;#model_height&quot;); this.modelHeightValue = $(&quot;#model_height_value&quot;); this.modelOrientation = $(&quot;#model_orientation&quot;); this.modelOrientationValue = $(&quot;#model_orientation_value&quot;); this.modelFrame = $(&quot;#model_frame&quot;); this.modelFrameValue = $(&quot;#model_frame_value&quot;); this.modelDelete = $(&quot;#delete_panel&quot;); var self = this; this.moreContent = $(&quot;#toolbar_more&quot;); this.showMoreButton = $(&quot;#show_more&quot;); this.showMoreButton.on('click', function () { var isVisible = self.moreContent.is(':visible'); if (isVisible) { self.hideMore(); } else { self.showMore(); } }); this.renderModelValues(); } /** * Zeigt die weiteren Einstellungen und passt die entsprechenden Elemente an. */ Toolbar.prototype.showMore = function () { this.showMoreButton.html(&quot;weniger&quot;); this.moreContent.show(); }; /** * Versteckt die weiteren Einstellungen und passt die entsprechenden Elemente an. */ Toolbar.prototype.hideMore = function () { this.showMoreButton.html(&quot;mehr&quot;); this.moreContent.hide(); }; /** * Aktualisiert die Slider und Werte in der Toolbar anhand des verknüpften Modells. */ Toolbar.prototype.renderModelValues = function () { if (this.selectedModel === undefined) { return; } this.toolsHeadline.html(this.selectedModel.name); var pitch = this.selectedModel.pitch || 0; this.modelTilt.val(pitch); this.modelTiltValue.html(parseFloat(pitch).toFixed(0) + &quot;°&quot;); var width = this.selectedModel.width || 1; this.modelWidth.val(width); this.modelWidthValue.html(width + &quot;m&quot;); var length = this.selectedModel.height || 1; this.modelHeight.val(length); this.modelHeightValue.html(length + &quot;m&quot;); var orientation = this.selectedModel.orientation || 0; this.modelOrientation.val(orientation); this.modelOrientationValue.html(parseFloat(orientation).toFixed(0) + &quot;°&quot;); var framewidth = (this.selectedModel.frameWidth * 100) || 0; this.modelFrame.val(framewidth); this.modelFrameValue.html(framewidth + &quot;cm&quot;); }; /** * Gewährt den Zugriff auf das Slider Element für die Neigung und gleichzeitig werden * die Werte bei einer Änderung in der Ansicht aktualisiert. * * @return {jQuery} Slider für die Neigung */ Toolbar.prototype.pitchSlider = function () { var degree = this.modelTiltValue; return this.modelTilt.on(&quot;change mousemove&quot;, function () { var val = $(this).val(); degree.html(val + &quot;°&quot;); }); }; /** * Gewährt den Zugriff auf das Slider Element für die Breite und gleichzeitig werden * die Werte bei einer Änderung in der Ansicht aktualisiert. * * @return {jQuery} Slider für die Breite */ Toolbar.prototype.widthSlider = function () { var widthVal = this.modelWidthValue; return this.modelWidth.on(&quot;change mousemove&quot;, function () { var val = $(this).val(); widthVal.html(val + &quot;m&quot;); }); }; /** * Gewährt den Zugriff auf das Slider Element für die Höhe und gleichzeitig werden * die Werte bei einer Änderung in der Ansicht aktualisiert. * * @return {jQuery} Slider für die Höhe */ Toolbar.prototype.heightSlider = function () { var height = this.modelHeightValue; return this.modelHeight.on(&quot;change mousemove&quot;, function () { var val = $(this).val(); height.html(val + &quot;m&quot;); }); }; /** * Gewährt den Zugriff auf das Slider Element für die Orientierung und gleichzeitig werden * die Werte bei einer Änderung in der Ansicht aktualisiert. * * @return {jQuery} Slider für die Orientierung */ Toolbar.prototype.orientationSlider = function () { var self = this; return this.modelOrientation.on(&quot;change mousemove&quot;, function () { self.setOrientation($(this).val(), true) }); }; /** * Setzen der Orientierung. Außerdem wird der Slider an die korrekte Position verschoben. * @public * @param {number} orientation - Wert für den Slider. * @param {boolean} isSlider - Gibt an ob der Aufruf der Funktion durch einen Slider durchgeführt wird. */ Toolbar.prototype.setOrientation = function (orientation, isSlider) { var slider = isSlider || false; this.modelOrientationValue.html(orientation + &quot;°&quot;); if (!slider) this.modelOrientation.val(&quot;&quot; + orientation) }; /** * Gewährt den Zugriff auf das Slider Element für die Rahmenbreite und gleichzeitig werden * die Werte bei einer Änderung in der Ansicht aktualisiert. * * @return {jQuery} Slider für die Rahmenbreite */ Toolbar.prototype.frameWidthSlider = function () { var frameWidth = this.modelFrameValue; return this.modelFrame.on(&quot;change mousemove&quot;, function () { var val = $(this).val(); frameWidth.html(val + &quot;cm&quot;); }); }; /** * Alle Eventlistener werden entkoppelt und die Toolbar wird für den Nutzer versteckt. */ Toolbar.prototype.unbindEvents = function () { this.modelTilt.off(); this.modelHeight.off(); this.modelWidth.off(); this.modelOrientation.off(); this.modelDelete.off(); this.modelFrame.off(); this.toolsContainer.addClass(&quot;hidden&quot;); $(&quot;#map_container&quot;).removeClass().addClass(&quot;col-sm-9&quot;); }; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" DocStrap Classes ControllerCookieHandlerEfficiencyDisplayMapMatrixPanelPanelStringRoofServerHandlerToolbar Global BEST_PVcalcNextPointcontrollerconvexHullCOOKIENAMEDAYS_TILL_COOKIE_EXPIREDEFAULT_ZOOMefficiencyTableevaluateEfficiencyHOSTINIT_LOCATIONinitAutocompletematrixSERVER_URL Global Members &lt;constant&gt; BEST_PV :number Bester Wert für die Effizienz anhand der Einstrahlungswerte. Type: number Source: Model/Roof.js, line 7 controller :Controller Controller der aktuellen Sitzung. Type: Controller Source: main.js, line 5 &lt;constant&gt; COOKIENAME :string Bestimmt den Namen der Cookies, die beim Nutzer abgelegt werden. Type: string Source: Controller/Controller.js, line 21 &lt;constant&gt; DAYS_TILL_COOKIE_EXPIRE :number Bestimmt die Dauer von neu erstellten Cookies in Tagen. Type: number Source: Controller/Controller.js, line 14 &lt;constant&gt; DEFAULT_ZOOM :number Gibt an mit welcher Zoomstufe die Karte bei der Initialisierung geladen werden soll. Type: number Source: View/Map.js, line 16 efficiencyTable :Array.&lt;Array.&lt;number&gt;&gt; LookUp-Tabelle mit Effektivitätsgrad mit entsprechender Neigung und Nord-Süd-Ausrichtung. Type: Array.&lt;Array.&lt;number&gt;&gt; Source: Utility/PanelEfficiency.js, line 6 See: https://www.photovoltaik-web.de/photovoltaik/dacheignung/dachneigung &lt;constant&gt; HOST :string Gibt die Host-IP oder die DNS des Datenbankservers an. Type: string Source: Controller/Controller.js, line 7 &lt;constant&gt; INIT_LOCATION :Array.&lt;number&gt; Gibt die Ort an, der beim Laden der Seite initial angezeigt wird.Gibt die Lokation, in Längen-, Breitengrad, an, die beim Laden der Seite als erstes angezeigt wird. Type: Array.&lt;number&gt; Source: View/Map.js, line 8 matrix :Matrix Matrix-Objekt, dass zur Berechnung der Drehungen genutzt wird. Type: Matrix Source: Model/Panel.js, line 5 &lt;constant&gt; SERVER_URL :string Bestimmt den Pfad der für die Nutzung des RESTWebservices genutzt wird. Type: string Source: Controller/Controller.js, line 27 Methods calcNextPoint(distance, point, angle) Hilfsfunktion zur Berechnung neuer Geodaten im Abhängigkeit zur Distanz in Metern, dem Ursprungspunkt und dem Winkel.Zur internen Rechnung wird ein Erdradius von 6.371.000 Metern angenommen, wodurch geringfügige Abweichung zur tatsächlichen Größe möglich sein können. Parameters: Name Type Description distance number Der Abstand in Metern zum Ursprungspunkt. point L.latLng Die Geodaten des Ursprungspunkt. angle number Der Winkel, in Grad, in denen sich der Zielpunkt befinden soll. Source: Model/Panel.js, line 254 Returns: Die Geodaten des berechnten Punktes. Type l.latLng convexHull(points) Es wird aus den übergeben Punkten die konvexe Hülle erstellt. Parameters: Name Type Description points Array.&lt;Array.&lt;number, number&gt;&gt; Alle Koordinaten der Dachfläche. Source: Model/Roof.js, line 213 See: https://de.wikipedia.org/wiki/Graham_Scan Returns: Koordinaten der konvexen Hülle. Type Array.&lt;Array.&lt;number, number&gt;&gt; evaluateEfficiency(panels, global) Die Effizienz eines Panels wird unter Berücksichtigung der Einstrahlwerte berechnet.Zur Berechnung wird eine Nennleistung von 1000 kWh und eine Effektivität von 15 % genutzt.Hierbei wird eine Südausrichtung mit 0 Grad angegeben und eine Nordausrichtung mit 180 Grad, während Westen und Osten jeweils zueinander identisch sind. Parameters: Name Type Description panels Array.&lt;panels&gt; Liste mit modifizierten Panelobjekten der Form: panels global number Einstrahlungswerte der Panels an der entsprechenden Position. Source: Utility/PanelEfficiency.js, line 44 Returns: Gibt die Effizienz im JSON Format zurück. Type Effizienz initAutocomplete() Callback für das von Google genutzte Autocomplete Objekt zur Auflösung der Adressinformationen.Der Controller der Sitzung wird initialisiert. Source: main.js, line 11 Type Definitions DachJson Type: Object Properties: Name Type Description dach_id number DachID gid number GebäudeID st number Eignung für die Solarthermie. pv number Eignung für die Photovoltaik. tilt number Dachneigung in Grad. global number Einstrahlungswerte der Dachfläche. the_geom Array.&lt;Array.&lt;number&gt;&gt; Array der Form [...[latitude, longitude],[latitude, longitude]...]. Source: Model/Roof.js, line 169 Effizienz Type: Object Properties: Name Type Description nominal number Nennleistung perYear number Leistung pro Jahr counter number Anzahl der Panels area number Fläche Source: Utility/PanelEfficiency.js, line 19 errorFunction() Callbackfunktion, der den Datenbankserver für den Controller deaktiviert. Source: Controller/Controller.js, line 583 getCookie(data) Callbackfunktion, die den Inhalt eines vom Datenbankserver empfangenen Cookies verarbeitet.Im Cookie enthalten sind die Liste aller Panels, die der Nutzer angelegt hat und auch das von Ihm zuletzt aufgerufene Dach. Parameters: Name Type Description data object Enthält JSON-Objekt mit alle vom Server erhaltenen Daten, die dem Cookie zugeordnert sind. Source: Controller/Controller.js, line 607 getRoof(data) Callbackfunktion, die ein vom Server empfangenes Dach verarbeitet. Parameters: Name Type Description data Roof JSON-Objekt, welches die Datenfelder eines Roof-Objekts enthält. Source: Controller/Controller.js, line 673 getRoofParts(data) Callbackfunktion, die alle vom Server empfangenen Dachteile verarbeitet. Parameters: Name Type Description data Array.&lt;Roof&gt; JSON-Objekte. welche die Datenfelder von Roof-Objekten enthalten. Source: Controller/Controller.js, line 702 panels Properties: Name Type Description height number Höhe width number Breite pitch number Neigung orientation number Orientierung Source: Utility/PanelEfficiency.js, line 27 postCookie(data) Callbackfunktion, der dem Benutzer eine CookieID zuteilt. Parameters: Name Type Description data object Enthält eine gültige CookieID und ein gültiges Ablaufdatum, die vom Datenbankserver ermittelt wurde. Source: Controller/Controller.js, line 592 × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" DocStrap Classes ControllerCookieHandlerEfficiencyDisplayMapMatrixPanelPanelStringRoofServerHandlerToolbar Global BEST_PVcalcNextPointcontrollerconvexHullCOOKIENAMEDAYS_TILL_COOKIE_EXPIREDEFAULT_ZOOMefficiencyTableevaluateEfficiencyHOSTINIT_LOCATIONinitAutocompletematrixSERVER_URL Classes Classes Controller CookieHandler EfficiencyDisplay Map Matrix Panel PanelString Roof ServerHandler Toolbar × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Classes ControllerCookieHandlerEfficiencyDisplayMapMatrixPanelPanelStringRoofServerHandlerToolbar Global BEST_PVcalcNextPointcontrollerconvexHullCOOKIENAMEDAYS_TILL_COOKIE_EXPIREDEFAULT_ZOOMefficiencyTableevaluateEfficiencyHOSTINIT_LOCATIONinitAutocompletematrixSERVER_URL Installationsanleitung Modulplazierer auf einem Luftbild für KleinanlagenEinrichtung der DatenbankZunächst muss dafür die Postgresql Datenbank installiert werden. Unter Linux gibt es dazu dafür den Befehlsudo apt-get install postgresql-9.4.Als nächstes wird die Postgis Erweiterung benötig, welche mitsudo apt-get install postgisinstalliert werden kann. Mit dem Befehl psql kann der Postgresserver erstmalig konfiguriert werden. Nun erstellt man mit dem Befehl CREATE DATABASE name eine neue Datenbank mit dem Namen scltest_sg_we2016_gr2a. Der Name kann natürlich frei gewählt werden, nur muss er dann in den folgenden Schritten angepasst werden. Um die Tabellen zu generieren wird ebenfalls psql benutzt.Mit psql -f create_db.sql -d scltest_sg_we2016_gr2a werden die Tabellen in der Datenbank erzeugt.Als nächsten muss ein Benutzer erzeugt werden, welcher die Datenbank verwalten soll. Dazu den Befehl CREATE USER -p scltest_sg_we2016_gr2a ausführen und anschließend ein neues Passwort vergeben. In diesem Fall wurde ein Nutzer mit dem Namen scltest_sg_we2016_gr2a erstellt. Zuletzt muss der neue User der Datenbank zugeordnet werden. Dazu den Befehl GRANT ALL PRIVILEGES ON DATABASE scltest_sg_we2016_gr2a to scltest_sg_we2016_gr2a.Die Datenbank ist nun eingerichtet und kann verwendet werden. Erstellung des RESTApi Web ArchivesIn dem Ordner SolarRESTService befindet sich ein Maven Projekt, welches mit der IntelliJ IDEA Entwicklungsumgebung erstellt worden ist. Dieser Ordner kann mit IntelliJ geöffnet werden. Anschließend muss unter File -&gt; Project Structure ein neues Artefakt vom Type Web Application: Archive erstellt werden. Der Name kann frei gewählt werden. Nun muss der Haken bei Build on make gesetzt werden. Danach mit einem Rechtsklick auf SolarRESTService und Put into Output Root auswählen. Mit einem Klick auf Apply werden die Einstellungen übernommen. Als letzten Schritt muss noch Build -&gt; Make Project ausgewählt werden und das Web Archive wird erstellt. Diese kann nur auf einem Server deployed werden. Einrichtung des ServersBei dem verwendeten Server handelt es sich um Payarafish 4.1. Dieser kann auf der Internetseite http://www.payara.fish/ kostenlos heruntergeladen werden. Nach dem Download muss die Zip-Datei entpackt werden und in den /bin Ordner navigiert werden. Dort befindet sich die asadmin Datei, mit welcher der Server gestartet werden kann../asadmin start-domain payaradomainNach dem Start des Server ist das Administratorinterface unter http://localhost:4848 erreichbar. Nun muss die Verbindung zur Datenbank hergestellt werden. Unter dem Reiter JDBC kann die Verbindung zur Datenbank konfiguriert werden. Klick auf JDBC Connection Pool Klick auf New Pool Name: SolarDB Resoruce Type: Javax.sql.ConnectionPoolDataSource Database Driver Vendor: Postgres Klick auf Next Nach Additional Properties scrollen Username: Der eingerichtete Username welcher die Datenbank verwaltet Port: Port auf dem die Datenbank erreichbar ist Password: Passwort des Users Databasename: Name der eingerichteten Datenbank Servername: Hostname der Datenbank Klick auf Finish Der Connection Pool für die Datenbank ist nun eingerichtet. Nun muss nur noch eine JDBC Resource eingerichtet werden. Dazu wieder auf den Reiter JDBC. Klick auf JDBC Resources Klick auf New JNDI Name: SolarDBWeb Pool Name: SolarDB auswählen Klick auf Finish Nun kann das SolarRESTService Archiv auf dem Server deplyed werden. Dazu einfach auf den Reiter Commen Task klicken und dann auf Deploy an Application. Nun eianfach die gewünscht .war Datei auswählen und sie wie auf dem Server deployen. Sie ist nun unter http://localhost:8080/Name_War/Pfad/ erreichbar. × Search results Close "},"Controller.html":{"id":"Controller.html","title":"Class: Controller","body":" DocStrap Classes ControllerCookieHandlerEfficiencyDisplayMapMatrixPanelPanelStringRoofServerHandlerToolbar Global BEST_PVcalcNextPointcontrollerconvexHullCOOKIENAMEDAYS_TILL_COOKIE_EXPIREDEFAULT_ZOOMefficiencyTableevaluateEfficiencyHOSTINIT_LOCATIONinitAutocompletematrixSERVER_URL Class: Controller Controller new Controller() Konstruiert ein Controller-Objekt.Das Kontrollerobjekt wird bereits mit einem ServerHandler zur Kommunikation mit dem Datenbankserver,einem CookieHandler zur Verwaltung und Interaktion des Benutzercookiesund einer Map, die die dargestellte Karte repräsentiert ausgestattet. Properties: Name Type Description serverIsAvailable boolean Gibt an, ob der Datenbankserver zur Verfügung steht. viewMap Map Hauptansicht der Karte viewAdress google.maps.places.Autocomplete Das Objekt, dass die Adresseingabe ermöglicht. toolbar Toolbar Werkzeugleiste zur Modifikation des Modells. serverHandler ServerHandler Handler zur Nutzung der REST-Schnittstelle. cookieHandler CookieHandler Handler zum Lesen und Schreiben von Cookies. roof Roof Das aktuell dargestellte Dachmodell. cookieId number Die vom Nutzer ausgelesene CookieID. efficiencyDisplay EfficiencyDisplay Anzeige zur Darstellung der Effektivität. Source: Controller/Controller.js, line 47 Methods appendModel(model, nextModel) Fügt einem Panelstring ein neues Panel hinzu. Stößt Speichervorgang für das hinzugefügte Panel an. Parameters: Name Type Description model PanelString PanelString welcher erweitert werden soll. nextModel Panel Panel, der hinzugefügt werden soll, wenn kein Panel übergeben wird, wird stattdessen ein neues Panel erstellt. Source: Controller/Controller.js, line 391 connectModelWithToolbar(polygon) Verbindet ein Polygon mit der Toolbar um dessen Modifikation zu ermöglichen.Hier werden die Listener für die HTML Elemente gesetzt, bzw. zuvorgesetzte Listener gelöscht,damit auch nur das ausgewählte Polygon modifiziert wird. Parameters: Name Type Description polygon L.Polygon Das Polygon mit dem die Toolbar verknüpft wird. Das Polygon muss mit einem Modell verknüpft sein. Source: Controller/Controller.js, line 195 convertModelToJsonString(model, masterId) Konvertiert ein Modell in einen JSON-String, zusätzlich werden dem JSON-String die aktuelle CookieID und ggf. die MasterpanelID hinzugefügt. Parameters: Name Type Description model Panel | PanelString | Roof Das Modell, das als JSON-String abgebildet werden soll. masterId number ID des Masterpanels welche dem JSON-String hinzugefügt werden soll. Source: Controller/Controller.js, line 378 Returns: JSON-String JSON-Objekt als String. Type string createRoof(data) Erstellt ein Roof-Objekt aus den Koordinaten, die übergeben wurden. Parameters: Name Type Description data Array Datensatz der eingezeichnten Koordinaten. Source: Controller/Controller.js, line 477 createUserCookie(cid, duedate) Erstellt einen Cookie beim Benutzer Parameters: Name Type Description cid number Die CookieID die dem Nutzer zugeteilt werden soll. duedate number Das Ablaufdatum als UNIX-Zeitstempel. Source: Controller/Controller.js, line 162 deleteUserCooke() Löscht den Cookie des Benutzers. Source: Controller/Controller.js, line 169 disableServer() Deaktiviert den Datenbankserver, wodurch weitere AJAX-Anfragen unterbunden werden. Source: Controller/Controller.js, line 108 drawRoof() Zeichnet ein Polygon auf die Karte, welche mit dem aktuellen Dachmodell verknüpft ist.Außerdem wird der Speichervorgang angestoßen, mit dem beim erneuten Besuchen der Internetseite das selbe Dach automatisch abgerufen wird. Source: Controller/Controller.js, line 336 enableServer() Aktiviert den Datenbankserver, wodurch AJAX-Anfragen wieder ermöglicht werden. Source: Controller/Controller.js, line 115 getGeoJSON(model) Liefert alle Geodaten eines Modells. Parameters: Name Type Description model PanelString | Panel Panel oder Panelstring, dessen Geodaten geliefert werden sollen. Source: Controller/Controller.js, line 442 Returns: Alle Geodaten des entsprechenden Modells als Liste. Type Array getLatLngAsPoint(latLng) Konvertiert ein L.latLng-Objekt in das entsprechende L.point-Objekt, relativ zur dargestellten Karte.Somit lassen sich Geodaten in Pixelkoordinaten konvertieren. Parameters: Name Type Description latLng L.latLng Objekt mit den Geodaten. Source: Controller/Controller.js, line 360 Returns: Den konvertierten Punkt. Type L.point getPanelEffiency() Berechnet die Effizienz aller dargestellten Panels. Zunächst werden alle Panels, die im aktuellen Dach liegen ermittelt.Sollten Sich nicht alle Panels im Dach befinden wir der Benutzer darauf aufmerksam gemacht.Außerdem wird dem Benutzer signalisiert, falls keine Einstrahlungswerte vorliegen, bspw. beim selbst eingezeichnten Dach.Wenn der Nutzer aktuell gar kein Dach abgebildet hat, wenn zum Beispiel keine Adresse eingegeben wurde,oder kein Dach gezeichnet wurde, wird dem Benutzer dies ebenfalls mitgeteilt. Source: Controller/Controller.js, line 510 getPointAsLatLng(point) Konvertiert ein L.point-Objekt in das entsprechende L.latLng-Objekt.Somit lassen sich Pixelkoordinaten in Geodaten konvertierten. Parameters: Name Type Description point L.point Source: Controller/Controller.js, line 369 Returns: Die konvertierten Geodaten. Type L.latLng getRoofFromServer(place) Verarbeitet, die vom Nutzer eingebene Adresse. Stößt Anfrage an den Datenbankserver an.Die Adresse sollte die Straße, Hausnummer und den Ort enthalten,ansonsten wird dem Benutzer ein Fehler angezeigt und es findet keine Anfrage an den Datenbankserver statt.Bei gültiger Adresse wird vom Datenbankserver das Roof-Objekt erfragt. Parameters: Name Type Description place Place Placeobjekt, welches verarbeitet werden soll. Source: Controller/Controller.js, line 297 See: https://developers.google.com/maps/documentation/javascript/places?hl=de für weitere Informationen. getRoofPartsFromServer() Frag den Datenbankserver nach Teildächern des Daches. Source: Controller/Controller.js, line 327 init() Initialisiert den Controller, hier werden grundsätzliche Funktionen des Frontends, der View, verknüpft.Hier wird der Knopf zum Hinzufügen weitere Modelle mit einem Clicklistener verknüpft.Auch wird hier das Adresseingabefeld mit einem Listener zur Auswertung der eigebenen Adresse verbunden.Außerdem werden die entsprechenden Viewkomponenten, wie die Karte, die Werkzeugleiste und die Darstellung der Effizienz initialisiert. Source: Controller/Controller.js, line 67 loadFromServer(forceNewCookie) Liest den Cookie des Nutzers aus. Wenn kein Cookie vorhanden ist wird stattdessen ein neuer Cookie angelegt. Sollte ein Cookie vorhanden sein wird der Cookie an den ServerHandler übergeben, um die Informationen die mit dem Cookie verknüpft sind abzurufen. Parameters: Name Type Description forceNewCookie boolean Erzwingt das Erstellen eines neuen Cookies. Source: Controller/Controller.js, line 126 removeAddressError() Entfernt einen zuvor angezeigten AdressError. Source: Controller/Controller.js, line 467 removeModel(model) Entfernt einem Panelstring ein Panel.Stößt Löschvorgang auf dem Datenbankserver an um zu löschendes Panel aus der Datenbank zu entfernen. Parameters: Name Type Description model PanelString Der Panelstring, dem ein Panel entfernt werden soll. Source: Controller/Controller.js, line 404 removeModelById(id) Löst Löschvorgang auf dem Datenbankserver aus. Parameters: Name Type Description id number Die ID, des Panels welches gelöscht werden soll. Source: Controller/Controller.js, line 415 savePanelstring(panelstring) Stößt Aktualisierungsvorgang für einen kompletten Panelstring auf dem Datenbankserver an. Parameters: Name Type Description panelstring PanelString Panelstring, dessen Panels auf dem Datenbankserver aktualisiert werden sollen. Source: Controller/Controller.js, line 426 saveToServer(panel, masterId) Stößt den Speicherprozess zur Speicherung eines Panels auf dem Datenbankserver an. Parameters: Name Type Description panel Panel Muss ein Panelobjekt sein, sonst wird eine ungültige Anfrage an den Server gestellt. masterId id Diese ID wird dem ServerHandler übergeben, um Panels zu einem Panelstring zu verbinden.-1 signalisiert, dass das Panel der Beginn eines neuen Panelstrings ist. Source: Controller/Controller.js, line 148 showAddressError() Signalisiert dem Benutzer, dass die Adresseingabe ungültig ist. Source: Controller/Controller.js, line 451 showCanNotFoundAddressError() Signalisiert dem Benutzer, dass keine Dachdaten für die Adresse vorhanden sind. Source: Controller/Controller.js, line 459 showEfficiency(efficiency, warningMessage) Verarbeitet die in getPanelEfficiency ermittelten Daten Parameters: Name Type Description efficiency object Containerobjekt mit den Daten, die dargestellt werden sollen. Objekt muss Nennleistung, KW pro Jahr, Anzahl und Fläche enthalten. warningMessage string Warnung, die ausgeben werden soll. Source: Controller/Controller.js, line 560 See: getPanelEfficiency updateModel(polygon, position, orientation) Übermittelt dem mit dem Polygon verknüpftem Modell Positions und/oder Ausrichtungsänderungen.Stößt den Speichervorgang zur Speicherung auf dem Datenbankserver an. Parameters: Name Type Description polygon L.Polygon Das Leafletpolygon, dass mit dem Modell verknüpft ist. position Array.&lt;Array.&lt;L.latLng&gt;&gt; Matrix mit den aktualisierten Koordinaten des Polygons. orientation number Orientierung in Grad, in die das Polygon gedreht wurde. Source: Controller/Controller.js, line 180 updatePolygonPosition(polygon) Richtet ein Polygon anhand dessen Modell neu aus. Parameters: Name Type Description polygon L.polygon Das Polygon, das neu ausgerichtet werden soll. Source: Controller/Controller.js, line 284 × Search results Close "},"CookieHandler.html":{"id":"CookieHandler.html","title":"Class: CookieHandler","body":" DocStrap Classes ControllerCookieHandlerEfficiencyDisplayMapMatrixPanelPanelStringRoofServerHandlerToolbar Global BEST_PVcalcNextPointcontrollerconvexHullCOOKIENAMEDAYS_TILL_COOKIE_EXPIREDEFAULT_ZOOMefficiencyTableevaluateEfficiencyHOSTINIT_LOCATIONinitAutocompletematrixSERVER_URL Class: CookieHandler CookieHandler new CookieHandler(name) Konstruiert ein CookieHandler-Objekt, dass Cookies vom Benutzer lesen, schreiben und löschen kann. Parameters: Name Type Description name string Der Name des Cookies, der gelesen, geschrieben oder gelöscht werden soll. Properties: Name Type Description name string Der gespeicherte Cookie-Name. Source: Handler/CookieHandler.js, line 8 Methods createCookie(value, dueDate) Erstellt einen Cookie mit dem Wert und Ablaufdatum. Parameters: Name Type Description value * Der Wert, der beim Nutzer geschrieben werden soll. Der Wert wird als String konvertiert (...&quot; &quot; + value + &quot; &quot;...).Somit ist grundsätzlich jeder Datentyp möglich, jedoch ist es sinnvoller nummerische Werte oder Strings statt Objekte zu nutzen. dueDate number Ablaufdatum als UNIX-Zeitstempel. Negative Werte führen dazu, dass der Cookie vom Browser gelöscht wird. Source: Handler/CookieHandler.js, line 17 eraseCookie() Löscht ein existierenden Cookie. Source: Handler/CookieHandler.js, line 45 readCookie() Liest einen Cookie vom Benutzer, der Cookie wird anhand des im CookieHandler gespeicherten Namen identifiziert. Source: Handler/CookieHandler.js, line 31 Returns: Wenn ein Cookie mit dem gespeicherten Namen vorhanden ist wird der gespeicherte Wert zurückgegeben.Wenn kein Cookie mit dem Namen gefunden wird, wird &quot;null&quot; zurückgegebeben. Type string | null × Search results Close "},"EfficiencyDisplay.html":{"id":"EfficiencyDisplay.html","title":"Class: EfficiencyDisplay","body":" DocStrap Classes ControllerCookieHandlerEfficiencyDisplayMapMatrixPanelPanelStringRoofServerHandlerToolbar Global BEST_PVcalcNextPointcontrollerconvexHullCOOKIENAMEDAYS_TILL_COOKIE_EXPIREDEFAULT_ZOOMefficiencyTableevaluateEfficiencyHOSTINIT_LOCATIONinitAutocompletematrixSERVER_URL Class: EfficiencyDisplay EfficiencyDisplay new EfficiencyDisplay() Repräsentiert die Anzeige für die Effizienz Properties: Name Type Description panelCounter jQuery Html Element für die Anzeige der Panelanzahl panelArea jQuery Html Element für die Anzeige der Quatratmeter panelNominal jQuery Html Element für die Anzeige der Nennleistung panelPerYear jQuery Html Element für die Anzeige den Stromertrag pro Jahr warningContainer jQuery Html Element für die Warnung warningMessage jQuery Html Element für die Anzeige der Warnung panel object Panel hält die Daten für die Anzeige Properties Name Type Description counter number Hält die Anzahl der Panels area number Hält die Anzahl der Panels nominal number Hält die Anzahl der Panels perYear number Hält die Anzahl der Panels Source: View/EfficiencyDisplay.js, line 3 Methods getPanelArea() Gibt die gesetzten Quadratmeter des Panelstrings wieder Source: View/EfficiencyDisplay.js, line 58 Returns: Quadratmeter Type number getPanelCounter() Gibt die Anzahl der Panels zurück Source: View/EfficiencyDisplay.js, line 39 Returns: Anzahl der Panels Type number getPanelNominal() Gibt die gesetzte Nennleistung zurück Source: View/EfficiencyDisplay.js, line 77 Returns: Nennleistung Type number getPerYear() Gibt den gesetzten Stromertrag zurück Source: View/EfficiencyDisplay.js, line 96 Returns: Stromertrag Type number hideWarning() Verbirgt den Warnhinweis Source: View/EfficiencyDisplay.js, line 124 setPanelArea(squareMeter) Setzt die Quadratmeter der Panelstring Fläche und zeigt diese an Parameters: Name Type Description squareMeter number Quadratmeter Source: View/EfficiencyDisplay.js, line 67 setPanelCounter(counter) Setzt die Anzahl der Panels und zeigt die an. Parameters: Name Type Description counter number Anzahl der Panels Source: View/EfficiencyDisplay.js, line 48 setPanelNominal(nominal) Setzt die Nennleistung und zeigt diese an Parameters: Name Type Description nominal number Nennleistung Source: View/EfficiencyDisplay.js, line 86 setPerYear(perYear) Setzt den Stromertrag pro Jahr und zeigt diesen an Parameters: Name Type Description perYear number Stromertrag Source: View/EfficiencyDisplay.js, line 105 showWarning(warning) Zeigt den Warnhinweis, mit der übergeben Warnung, an. Parameters: Name Type Description warning string Warnung Source: View/EfficiencyDisplay.js, line 115 × Search results Close "},"Map.html":{"id":"Map.html","title":"Class: Map","body":" DocStrap Classes ControllerCookieHandlerEfficiencyDisplayMapMatrixPanelPanelStringRoofServerHandlerToolbar Global BEST_PVcalcNextPointcontrollerconvexHullCOOKIENAMEDAYS_TILL_COOKIE_EXPIREDEFAULT_ZOOMefficiencyTableevaluateEfficiencyHOSTINIT_LOCATIONinitAutocompletematrixSERVER_URL Class: Map Map new Map() Konstruktor des Map-Objektes.Das Map-Objekt ist eine Containerklasse zur Darstellung von Karten der Kartenprovider GoogleMaps und Openstreetmap.Darüberhinaus das Objekt der Visualisierung von beweglichen und unbeweglichen Polygonen. Properties: Name Type Description map L.map Karte die dargestellt wird. mapProvider L.tileLayer | L.gridLayer.googleMutant Layer der Karte die dargestellt wird. controller Controller Der mit der Karte assoziierte Controller. moveablePolygons Array.&lt;L.polygon&gt; Liste aller beweglichen Polygonen. nonMoveablePolygon Array.&lt;L.polygon&gt; Liste aller unbeweglicher Polygone. selectedPolygon L.polygon Aktuell ausgewähltes Polygon. d3Overlay L.d3SvgOverlay Layer zur Berechnung von Koordinaten. handlerGroup L.LayerGroup Layer mit beweglichen Polygonen. Source: View/Map.js, line 33 Methods addMultiPolygon(model) Hier wird ein bewegliches Polygon als Multipolygon angelegt.Dies wird mit einem Clicklistener verknüpft, außerdem werden Handler für die Rotation, Skalierung und Drag-Funktionalität eingerichtet.Das Polygon wird auf der Karte dargestellt und in die Liste der beweglichen Polygone eingefügt. Parameters: Name Type Description model Panel | PanelString Das Model, dass mit dem Polygon assoziert wird. Die Geodaten werden vom Controller ermittelt {link Controller#getGeoJSON}. Source: View/Map.js, line 98 Returns: Das angelegte Polygon. Type L.polygon addNonMovable(model) Hier wird ein nicht bewegliches Polygon angelegt. Das Polygon wird in den Hintergrund verschoben, um bewegliche Polygone nicht einzuschränken.Das Polygon wird in die Liste der unbeweglichen Polygone eingefügt. Parameters: Name Type Description model Roof Darzustellendes unbewegliches Model, welches mit dem Polygon verknüpft wird. Source: View/Map.js, line 184 changeMapProvider(layer) Es wird der übergebe Layer als Kartenlayer angezeigt und der vorher ausgewählte wird entfernt. Parameters: Name Type Description layer L.tileLayer | L.gridLayer.googleMutant Kartenlayer Source: View/Map.js, line 274 containerPointToLatLng(point) Konvertiert Längen- und Breitengrad zu dem entsprechendem Punkt (X/Y-Koordinaten).Unter Berücksichtigung der Größe des entsprechenden HTML-Elementes. Parameters: Name Type Description point L.point Punkt auf der Karte Source: View/Map.js, line 241 Returns: Längen-, Breitengrad Type L.latLng init() Initialisierung der Karte, hier werden die Buttons mit Funktionen der Karte verknüpft und die Karte vom Kartenprovider geladen. Source: View/Map.js, line 48 latLngToLayerPoint(latLng) Konvertiert Längen- und Breitengrad zu dem entsprechendem Punkt (X/Y-Koordinaten). Parameters: Name Type Description latLng L.latLng Koordinaten als Längen-, Breitengrad Source: View/Map.js, line 229 Returns: Punkt auf der Karte Type L.point layerPointToLatLng(point) Konvertiert einen Punkt auf der Karte zu einem Längen- und Breitengrad. Parameters: Name Type Description point L.point Punkt auf der Karte. Source: View/Map.js, line 219 Returns: Längen-, Breitengrad. Type L.latLng removeAllNonMoveable() Entfernt alle nicht beweglichen Polygone von der Karte und aus der Liste der nicht beweglichen Polygone. Source: View/Map.js, line 194 removeSelected() Es wird das ausgewählte Panel von der Karte und aus der Liste der beweglichen Polygone entfernt. Source: View/Map.js, line 286 selectPolygon(selectedPolygon) Es wird angegeben, welches Polygon Objekt ausgewählt wurde.Hierzu wird noch zusätzlich die Controller#connectModelWithToolbar aktiviert,um Einstellungen für die das selektiere Polygon durchzuführen. Parameters: Name Type Description selectedPolygon L.polygon Ausgewähltes Polygon-Objekt. Source: View/Map.js, line 85 setFocus(lat, lng) Die Karte wird auf die übergebenen Koordinaten, mit der Standardzoomstufe, zentriert. Parameters: Name Type Description lat number Längengrad (latitude) lng number Breitengrad (longitude) Source: View/Map.js, line 206 showGoogle() Zeigt als Kartenlayer Google Maps an Source: View/Map.js, line 248 showOpenstreet() Zeigt als Kartenlayer Openstreetmap an Source: View/Map.js, line 259 × Search results Close "},"Matrix.html":{"id":"Matrix.html","title":"Class: Matrix","body":" DocStrap Classes ControllerCookieHandlerEfficiencyDisplayMapMatrixPanelPanelStringRoofServerHandlerToolbar Global BEST_PVcalcNextPointcontrollerconvexHullCOOKIENAMEDAYS_TILL_COOKIE_EXPIREDEFAULT_ZOOMefficiencyTableevaluateEfficiencyHOSTINIT_LOCATIONinitAutocompletematrixSERVER_URL Class: Matrix Matrix new Matrix() Konstruiert ein Matrix-Objekt.Das Matrix-Objekt ist eine Hilfsklasse, die Rotationsmatrizen zur Rotation entlang der X-/Z-Achse liefert.Bei den Matrizen handelt es sich um 3x3-Matrizen.Außerdem stellt das Objekt die Funktionalität zur Verfügung eine 3x3 Matrix mit einem Vektor (x,y,z) zu multiplizieren. Properties: Name Type Description lastOrientation number Der zuletzt berechnte Rotationswinkel der Z-Rotationsmatrix. lastOrientationMatrix Array.&lt;Array.&lt;number&gt;&gt; Die der zuletzt berechneten Z-Rotationsmatrix in Relation zum zuletzt berechnten Rotationswinkel. lastPitch number Der zuletzt berechnte Rotationswinkel der X-Rotationsmatrix. lastPitchMatrix Array.&lt;Array.&lt;number&gt;&gt; Die der zuletzt berechneten X-Rotationsmatrix in Relation zum zuletzt berechneten Rotationswinkel. Source: Utility/Matrix.js, line 13 Methods calculateOrientationMatrix(orientation) Berechnet die Rotationsmatrix zur Rotation entlang der Z-Achse.Berechnungen werden gespeichert um ggf. identische Berechnungen, die nacheinander durchgeführt werden, zu verhindern. Parameters: Name Type Description orientation number Der Drehwinkel der zur Berechnung der Matrix genutzt wird. Source: Utility/Matrix.js, line 26 Returns: Die Rotationsmatrix 3x3 die berechnet oder aus dem Speicher gelesen wird.Gibt die zuletzt gespeicherte Matrix zurück wenn &quot;null&quot; übergeben wird. Type Array.&lt;Array.&lt;number&gt;&gt; | null calculatePitchMatrix(pitch) Berechnet die Rotationsmatrix zur Rotation entlang der X-Achse.Berechnungen werden gespeichert um ggf. identische Berechnungen, die nacheinander durchgeführt werden, zu verhindern. Parameters: Name Type Description pitch number Der Drehwinkel der zur Berechnung der Matrix genutzt wird. Source: Utility/Matrix.js, line 45 Returns: Die Rotationsmatrix 3x3 die berechnet oder aus dem Speicher gelesen wird.Gibt die zuletzt gespeicherte Matrix zurück wenn &quot;null&quot; übergeben wird. Type Array.&lt;Array.&lt;number&gt;&gt; | null matrixMultiplyVector(matrix, vector) Multipliziert eine 3x3 Matrix mit einem Vektor (x,y,z). Parameters: Name Type Description matrix Array.&lt;Array.&lt;number&gt;&gt; Matrix der Form 3x3. vector Array.&lt;number&gt; Vektor aus drei Komponenten.Bei Vektoren, die aus mehr Komponenten bestehen werden die weiteren Komponenten ignoriert und es wird so verfahren,als ob der Vektor nur drei Komponenten hätte. Source: Utility/Matrix.js, line 65 Returns: Das Ergebnis der Multiplikation, ein Vektor aus drei Komponenten. Type Array.&lt;number&gt; × Search results Close "},"Panel.html":{"id":"Panel.html","title":"Class: Panel","body":" DocStrap Classes ControllerCookieHandlerEfficiencyDisplayMapMatrixPanelPanelStringRoofServerHandlerToolbar Global BEST_PVcalcNextPointcontrollerconvexHullCOOKIENAMEDAYS_TILL_COOKIE_EXPIREDEFAULT_ZOOMefficiencyTableevaluateEfficiencyHOSTINIT_LOCATIONinitAutocompletematrixSERVER_URL Class: Panel Panel new Panel() Konstruiert ein Solarpanel (Panel-Objekt). Properties: Name Type Description oTopLeft L.latLng Stellt die Ursprungskoordinaten für den Punkt im Nordwesten dar. oTopRight L.latLng Stellt die Ursprungskoordinaten für den Punkt im Nordosten dar. oBotLeft L.latLng Stellt die Ursprungskoordinaten für den Punkt im Südwesten dar. oBotLeft L.latLng Stellt die Ursprungskoordinaten für den Punkt im Südosten dar. topLeft L.latLng Stellt die Koordinaten für den Punkt im Nordwesten, unter Berücksichtigung der Rotation, dar. topRight L.latLng Stellt die Koordinaten für den Punkt im Nordosten, unter Berücksichtigung der Rotation, dar. botLeft L.latLng Stellt die Koordinaten für den Punkt im Südwesten, unter Berücksichtigung der Rotation, dar. botRight L.latLng Stellt die Koordinaten für den Punkt im Südosten, unter Berücksichtigung der Rotation, dar. orientation number Die Rotation entlang der Paneleigenen Z-Achse. pitch string Die Rotation entlang der Paneleigenen X-Achse. height number Die Höhe/Länge des Panels in Meter. width number Die Breite des Panels in Meter. frameWidth number Die Rahmenbreite des Panels in Meter. id number Die ID des Panels. Source: Model/Panel.js, line 26 Methods align(controller, width, height) Justiert das Panel neu aufgrund von veränderten Koordinaten oder veränderte Breite/Länge. Parameters: Name Type Description controller Controller Der Controller der benötigt wird um Koordinaten von Geodaten in X/Y-Koordinaten umzurechnen. width number | undefined Neue Breite des Panels, wenn nicht definiert, wird die bereits vorhandene Breite genutzt. height number | undefined Neue Länge/Höhe des Panels, wenn nicht definiert, wird die bereits vorhande Länge genutzt. Source: Model/Panel.js, line 49 getAsJson() Konvertiert das Panel in ein JSON Objekt. Source: Model/Panel.js, line 180 Returns: JSON-Objekt mit allen Informationen des Panels. Attribute sind panel_id, the_geom[[latitude,longitude]], laenge, breite, neigung, ausrichtung und rahmenbreite. getFrameWidth() Getter für die Rahmenbreite. Source: Model/Panel.js, line 116 Returns: Rahmenbreite in Metern. Type number getFrameWidthInPixel(controller) Berechnet die Rahmenbreite in Pixel. Parameters: Name Type Description controller Controller Der Controller der benötigt wird um Koordinaten von Geodaten in X/Y-Koordinaten umzurechnen. Source: Model/Panel.js, line 104 Returns: Die Rahmenbreite in Pixel. Type number getId() Getter für die ID des Panels. Source: Model/Panel.js, line 242 Returns: ID des Panels. Type number getLatLngsAsArray() Konvertiert die Punkte des Panels in ein Listenformat([[NW.latitude, NW.longitude], [NO.latitude, NW.longitude], [SO.latitude, SO.longitude], [SW.latitude, SW.longitude]]),Listenobjekte enhalten die Geodaten. Source: Model/Panel.js, line 168 Returns: Array der Länge Vier. Jeder Eintrag enthält ein Array der Länge Zwei [Latitude, Longitude]. Type Array.&lt;Array.&lt;number&gt;&gt; getPointsAsList() Konvertiert die Punkte des Panels in ein Listenformat ([NW, NO, SO, SW]), Listenobjekte enhalten die Geodaten. Source: Model/Panel.js, line 159 Returns: Array der Länge Vier. Type Array.&lt;L.latLng&gt; setFrameWidth(controller, width) Setter für die Rahmenbreite. Parameters: Name Type Description controller Controller Der Controller der zur Berechnung der Panelgrößen notwendig ist, interner Aufruf von align {@see align} width number Die neue Rahmenbreite in Metern. Source: Model/Panel.js, line 124 setOrientation(controller, orientation) Setter für die Ausrichtung des Panels. Parameters: Name Type Description controller Controller Der Controller der zur Berechnung der Panelgrößen notwendig ist, interner Aufruf von align {@see align} orientation number Die neue Ausrichtung des Panels in Grad. Source: Model/Panel.js, line 133 setPitch(controller, pitch) Setter für die Neigung des Panels. Parameters: Name Type Description controller Controller Der Controller der zur Berechnung der Panelgrößen notwendig ist, interner Aufruf von align {@see align} pitch number Die neue Neigung des Panels in Grad. Source: Model/Panel.js, line 142 setPointsFromList(list) Liest die Punkte einer übergebenen Liste der Form Liste[[latitude, longitude]]. Und setzt anhand dieser die Panelkoordinaten neu. Parameters: Name Type Description list Array.&lt;Array.&lt;number&gt;&gt; Liste der Länge Vier. Punkte werden der Reihe nach neu gesetzt: NW, NO, SW, SO. Source: Model/Panel.js, line 211 setTopLeft(controller, topLeft) Setter für die nordwestlichste Koordinate des Panels. Parameters: Name Type Description controller Controller Der Controller der zur Berechnung der Panelgrößen notwendig ist, interner Aufruf von align {@see align} topLeft L.latLng Geodaten der Koordinate. Source: Model/Panel.js, line 151 × Search results Close "},"PanelString.html":{"id":"PanelString.html","title":"Class: PanelString","body":" DocStrap Classes ControllerCookieHandlerEfficiencyDisplayMapMatrixPanelPanelStringRoofServerHandlerToolbar Global BEST_PVcalcNextPointcontrollerconvexHullCOOKIENAMEDAYS_TILL_COOKIE_EXPIREDEFAULT_ZOOMefficiencyTableevaluateEfficiencyHOSTINIT_LOCATIONinitAutocompletematrixSERVER_URL Class: PanelString PanelString new PanelString() Properties: Name Type Description unifier number Dem PanelString zugeordneter Zähler zur eindeutigen Identifizierung controller Controller Hauptcontroller um die richtige Darstellung auf der Karte zu gewährleisten. masterPanel Panel Hauptpanel an dem sich die Panels des PanelStrings ausrichten. panels Array.&lt;Panel&gt; Panels, die an den Hauptpanel angehängt wurden. Source: Model/PanelString.js, line 1 Methods &lt;static&gt; PanelString(controller, masterPanel) Erstellt ein PanelString Object. Das PanelString Object verwaltet die korrekte Aneinanderreihung der Panels.Die Haupteinstellungen werden am übergeben MasterPanel getätigt und anschließend an die angehängten Panels weitergegeben.Beim Anlegen eines neuen PanelStrings wird die statische UNIFIER-Variable inkrementiert. Parameters: Name Type Description controller Controller Der Hauptcontroller um den PanelString korrekt darzustellen. masterPanel Panel MasterPanel, an dem sich angehängte Panels ausrichten. Source: Model/PanelString.js, line 20 align(controller, width, height) Der Aufruf der Funktion wird an die Ausrichtungfunktion Panel#align des Hauptpanels weitergeleitet. Parameters: Name Type Description controller Controller Hauptcontroller, zur Berechnung der Ausrichtung. width number Breite des Panels. height number Höhe/Länge des Panels. Source: Model/PanelString.js, line 52 appendPanel(panel) Es wird ein erstelltes Panel übergeben, welches anschließend die Eigenschaften des MasterPanels übernimmt.Das angehängte Panel wird zusätzlich der Panelliste des PanelString hinzugefügt. Parameters: Name Type Description panel Panel Anzuhängendes Panel. Source: Model/PanelString.js, line 33 equals(panelstring) Vergleicht aktuelles PanelString mit dem übergeben PanelString. Parameters: Name Type Description panelstring PanelString Ein PanelString. Source: Model/PanelString.js, line 226 Returns: Gibt an ob der übergebene PanelString der selbe PanelString ist wie dieser. Type boolean get(index) Gibt das Panel entsprechenden Stelle aus.Wobei 0 das erste Panel ist. Parameters: Name Type Description index number Index des gewünschten Panels. Source: Model/PanelString.js, line 190 Returns: Panel an der übergebenen Position. Bei ungültigen Indices wird null zurückgegeben. Type Panel | null getFrameWidth() Gibt die Rahmenbreite in Pixel wieder. Source: Model/PanelString.js, line 130 Returns: Gibt die Rahmenbreite in Pixel wieder Type number getGeoJSON() Gibt einen Array aller Panels mit entsprechen Längen- und Breitengraden (Panel#getLatLngsAsArray) wieder Source: Model/PanelString.js, line 173 Returns: Array der Längen- und Breitengraden aller Panels Type Array getId() Gibt die ID des MasterPanels zurück. Source: Model/PanelString.js, line 216 Returns: ID des MasterPanels Type number getPointsAsList() Gibt die Liste aller Längen- und Breitengrade eines PanelStrings wieder. Source: Model/PanelString.js, line 61 Returns: Liste aller Längen- und Breitengrade Type Array removePanel() Entfernt das zuletzt eingefügten Panel. Das MasterPanel kann so nicht entfernt werden. Source: Model/PanelString.js, line 71 Returns: Gibt die Id des entfernten Panel zurück.Wenn kein Panel gelöscht werden kann, wird die ID des MasterPanels zurückgegeben. Type string | number setFrameWidth(width) Der Aufruf der Funktion wird an die Setter-Funktion für die Rahmenbreite Panel#setFrameWidth des Hauptpanels weitergeleitet. Parameters: Name Type Description width number Rahmenbreite des Panels. Source: Model/PanelString.js, line 101 setOrientation(orientation) Hier wird die Orientierung des PanelString gesetzt, hierbei wird die Orientierung nur beim MasterPanel gesetzt,um die Orientierung auf die angehängten Panele zu übertragen ist der Funktionsaufruf zur Aktualisierung der Geometrischen EigenschaftenPanelString#refreshGeometrics notwendig. Parameters: Name Type Description orientation number Orientierung von 0-360 Grad. Source: Model/PanelString.js, line 88 setPitch(pitch) Der Aufruf der Funktion wird an die Setter-Funktion für die NeigungPanel#setPitch des Hauptpanels weitergeleitet. Parameters: Name Type Description pitch number Neigung des Panels. Source: Model/PanelString.js, line 110 setPosition(latlngs) Die Position des MasterPanels wird neu gesetzt. Parameters: Name Type Description latlngs Array.&lt;Array.&lt;L.latLng&gt;&gt; Längen- und Breitengrade der neuen Koordinaten. Source: Model/PanelString.js, line 119 size() Gibt die Anzahl der Panels im PanelString zurück. Source: Model/PanelString.js, line 207 Returns: Anzahl der Panels. Type number × Search results Close "},"Roof.html":{"id":"Roof.html","title":"Class: Roof","body":" DocStrap Classes ControllerCookieHandlerEfficiencyDisplayMapMatrixPanelPanelStringRoofServerHandlerToolbar Global BEST_PVcalcNextPointcontrollerconvexHullCOOKIENAMEDAYS_TILL_COOKIE_EXPIREDEFAULT_ZOOMefficiencyTableevaluateEfficiencyHOSTINIT_LOCATIONinitAutocompletematrixSERVER_URL Class: Roof Roof new Roof() Das Roof-Objekt repräsentiert ein Dach eines Gebäudes. Properties: Name Type Description gid number Die GebäudeID. roofId number Die ID der Dachfläche. points Array.&lt;L.latLng&gt; Koordinaten der Dachfläche. pv number Eignung der Dachfläche für Photovoltaik-Module. st number Eignung der Dachfläche für die Solarthermie. orientation number Ausrichtung der Dachfläche in Richtung Süden in Grad. parts Array.&lt;Roof&gt; Liste der Dachteilflächen. bestPart number Index der besten Dachteilfläche aus der Liste der Dachteilflächen.Die Qualität wird anhand der besten PV-Eignung und den besten Einstrahlungswerten ermittelt. tilt number Der Winkel der Dachneigung in Grad. global number Die globalen Einstrahungswerte der Dachfläche. Source: Model/Roof.js, line 27 Methods addPart(part) Hier wird einem Dach eine Dachfläche hinzugefügt. Ein Dach ist eine Sammlung mehrerer Dachflächen, die für sich jeweils Dächer sind. Parameters: Name Type Description part Roof Dach, welches dem Dach hinzugefügt wird. Source: Model/Roof.js, line 83 calculateOrientation(controller) Berechnung der Ausrichtung des Daches. Parameters: Name Type Description controller Controller Wird benötigt um die Geodaten in X/Y-Koordinaten zu transformieren um anhand dieser die Ausrichtung zu berechnen. Source: Model/Roof.js, line 114 getAsJson() Gibt uns das Dachobjekt als Json zurück Source: Model/Roof.js, line 185 Returns: Dach als Json Type DachJson getAsPolygon() Konvertiert ein Dach in ein Polygon, je nach Eignung wird die Farbe in Farbabstufung Rot (niedrige Eignung) bis Grün(hohe Eignung) gesetzt.Außerdem wird die Polygonfläche einer Teilfläche mit dem jeweiligen Farbton gefüllt, während vom eigentlich Dach lediglich die Umrisse dargestellt werden. Source: Model/Roof.js, line 55 Returns: Dach als Polygon. Type L.polygon getBestRoofPart(controller) Getter für den zur Photovoltaik am besten geeigneten Dachteil. Parameters: Name Type Description controller Controller Wird benötigt, um ggf. die Ausrichtung der Dachteilfläche zu berechnen. Source: Model/Roof.js, line 101 Returns: Beste Teilfläche für die Photovoltaik. Type Roof panelInRoof(panel) Die Funktion überprüft ob sich ein Panel innerhalb eines Dachs befindet.Sollte sich das Panel ausserhalb des Dachs befinden, wird false zurückgegeben, sonst true. Parameters: Name Type Description panel Panel | PanelString Panel- oder PanelString-Objekt Source: Model/Roof.js, line 145 Returns: Gibt an ob sich die Panels auf dem Dach befinden Type boolean setPointsFromList(coordinates) Die Dachfläche wird anhand der übergebene Koordinaten, als konvexe Fläche ermittelt. Parameters: Name Type Description coordinates Array.&lt;L.latLng&gt; Geo-Koordinaten der Dachfläche Source: Model/Roof.js, line 45 See: {convexHull} × Search results Close "},"ServerHandler.html":{"id":"ServerHandler.html","title":"Class: ServerHandler","body":" DocStrap Classes ControllerCookieHandlerEfficiencyDisplayMapMatrixPanelPanelStringRoofServerHandlerToolbar Global BEST_PVcalcNextPointcontrollerconvexHullCOOKIENAMEDAYS_TILL_COOKIE_EXPIREDEFAULT_ZOOMefficiencyTableevaluateEfficiencyHOSTINIT_LOCATIONinitAutocompletematrixSERVER_URL Class: ServerHandler ServerHandler new ServerHandler(url) Konstruiert ein ServerHandler-Objekt, dass die Kommunikationmit der REST-Schnittstelle des als Parameter angegebenen Servers übernimmt. Parameters: Name Type Description url string Die URL des Servers mit dem kommuniziert werden soll. Properties: Name Type Description serverUrl string Die URL des Servers. errorFunction function Eine Standardfunktion, die im Fehlerfall ausgeführt wird. Source: Handler/ServerHandler.js, line 10 Methods getCookie(id, callback) Löst den GET-Request cookie/getCookie/, des in der URL des ServerHandlers gespeicherten Servers, aus.Die Anfrage hat die Form &quot;URL/cookie/getCookie/id&quot; Parameters: Name Type Description id number Die ID, die der Serverfunktion übergeben wird. callback function Die Funktion, die im Erfolgfall aufgerufen werden soll. Die Funktion erhält den vom Server enhaltende Response. Source: Handler/ServerHandler.js, line 22 getPredefinedRoof(street, nr, citycode, callback) Löst den GET-Request dach/getPredefinedRoof/ des in der URL des ServerHandlers gespeicherten Servers aus.Die Anfrage hat die Form &quot;URL/dach/getPredefinedRoof/street/nr/citycode&quot; Parameters: Name Type Description street string Der Straßenname, der dem Server übergeben wird. nr number Die Hausnummer, die dem Server übergeben wird. citycode number Die Postleitzahl, die dem Server übergeben wird. callback function Die Funktion, die im Erfolgfall aufgerufen werden soll. Die Funktion erhält den vom Server enhaltenen Response. Source: Handler/ServerHandler.js, line 36 getRoofParts(gid, callback) Löst den GET-Request dach/getRoofParts/ ,des in der URL des ServerHandlers gespeicherten Servers, aus.Die Anfrage hat die Form &quot;URL/dach/getRoofParts/gid&quot; Parameters: Name Type Description gid number Die GebäudeID, die dem Server übergeben wird. callback function Die Funktion, die im Erfolgfall aufgerufen werden soll. Die Funktion erhält den vom Server erhaltende Response. Source: Handler/ServerHandler.js, line 48 postCookie(json, callback) Löst den POST-Request, des in der URL des ServerHandlers gespeichtern Servers, aus.Die Server-Funktion &quot;cookie/postCookie&quot; wird genutzt. Parameters: Name Type Description json string Das JSON-Objekt, als String, welches dem Server übermittelt wird. callback function Die Funktion, die im Erfolgfall aufgerufen werden soll. Die Funktion erhält den vom Server erhaltende Response. Source: Handler/ServerHandler.js, line 72 postPanel(json, model, callback) Löst den POST-Request, des in der URL des ServerHandlers gespeichtern Servers, aus.Die Server-Funktion &quot;panel/postPanel&quot; wird genutzt. Parameters: Name Type Description json string Das JSON-Objekt, als String, welches dem Server übermittelt wird. model Panel Das Panel, welches im Erfolgsfall der Callbackfunktion übergeben wird. callback function Die Funktion, die im Erfolgfall aufgerufen werden soll.Die Funktion erhält den vom Server enhaltenen Response und das Model welches postPanel-Funktion übergeben wurde. Source: Handler/ServerHandler.js, line 86 postRoof(json, callback) Löst den POST-Request, des in der URL des ServerHandlers gespeicherten Servers, aus.Die Server-Funktion &quot;dach/postRoof&quot; wird genutzt. Parameters: Name Type Description json string Das JSON-Objekt, als String, welches dem Server übermittelt wird. callback function Die Funktion, die im Erfolgfall aufgerufen werden soll. Die Funktion erhält den vom Server enhaltenen Response. Source: Handler/ServerHandler.js, line 109 removePanel(id, callback) Löst den GET-Request panel/removePanel/, des in der URL des ServerHandlers gespeicherten Servers, aus.Die Anfrage hat die Form &quot;URL/panel/removePanel/id&quot; Parameters: Name Type Description id number Die PanelID, die dem Server übergeben wird. callback function Die Funktion, die im Erfolgfall aufgerufen werden soll. Die Funktion erhält den vom Server erhaltende Response. Source: Handler/ServerHandler.js, line 60 updatePanel(json, callback) Löst den POST-Request, des in der URL des ServerHandlers gespeicherten Servers, aus. Die Server-Funktion &quot;panel/updatePanel&quot; wird genutzt. Parameters: Name Type Description json string Das JSON-Objekt, als String, welches dem Server übermittelt wird. callback function Die Funktion, die im Erfolgfall aufgerufen werden soll. Die Funktion erhält den vom Server enhaltenen Response. Source: Handler/ServerHandler.js, line 98 × Search results Close "},"Toolbar.html":{"id":"Toolbar.html","title":"Class: Toolbar","body":" DocStrap Classes ControllerCookieHandlerEfficiencyDisplayMapMatrixPanelPanelStringRoofServerHandlerToolbar Global BEST_PVcalcNextPointcontrollerconvexHullCOOKIENAMEDAYS_TILL_COOKIE_EXPIREDEFAULT_ZOOMefficiencyTableevaluateEfficiencyHOSTINIT_LOCATIONinitAutocompletematrixSERVER_URL Class: Toolbar Toolbar new Toolbar(model) Die Toolbar dient dazu Einstellungen an einem PanelString oder Panel vorzunehmen.Modifizierbar sind Breite, Länge, Ausrichtung, Neigung und Rahmenbreite. Parameters: Name Type Description model Panel | PanelString Model, welches bearbeitet werden soll. Properties: Name Type Description isPanelString boolean Hält die Information ob es sich hierbei um einem PanelString oder Panel handelt. selectedModel Panel | PanelString Ausgewähltes Modell. toolsContainer jQuery Das HTML-Element für die Werkzeugleiste. toolsHeadline jQuery HTML Element für die Überschrift modelTilt jQuery Slider für die Einstellung der Neigung modelTiltValue jQuery HTML Element für den Wert der Neigung modelWidth jQuery Slider für die Einstellung der Breite modelWidthValue jQuery HTML Element für die Anzeige der Breite modelHeight jQuery Slider für die EInstellung der Höhe modelHeightValue jQuery HTML Element für die Anzeige der Höhe modelOrientation jQuery Slider für die Einstellung der Orientierung modelOrientationValue jQuery HTML Element für die Anzeige der Orientierung modelFrame jQuery Slider für die Einstellung der Rahmenbreite modelFrameValue jQuery HTML Element für die Anzeige der Rahmenbreite modelDelete jQuery Button für die Löschung des Panels moreContent jQuery HTML Kontainer der weitere Einstellungsmöglichkeiten versteckt showMoreButton jQuery Button für die Klickevents von moreContent Source: View/Toolbar.js, line 27 Methods frameWidthSlider() Gewährt den Zugriff auf das Slider Element für die Rahmenbreite und gleichzeitig werdendie Werte bei einer Änderung in der Ansicht aktualisiert. Source: View/Toolbar.js, line 194 Returns: Slider für die Rahmenbreite Type jQuery heightSlider() Gewährt den Zugriff auf das Slider Element für die Höhe und gleichzeitig werdendie Werte bei einer Änderung in der Ansicht aktualisiert. Source: View/Toolbar.js, line 155 Returns: Slider für die Höhe Type jQuery hideMore() Versteckt die weiteren Einstellungen und passt die entsprechenden Elemente an. Source: View/Toolbar.js, line 85 orientationSlider() Gewährt den Zugriff auf das Slider Element für die Orientierung und gleichzeitig werdendie Werte bei einer Änderung in der Ansicht aktualisiert. Source: View/Toolbar.js, line 169 Returns: Slider für die Orientierung Type jQuery pitchSlider() Gewährt den Zugriff auf das Slider Element für die Neigung und gleichzeitig werdendie Werte bei einer Änderung in der Ansicht aktualisiert. Source: View/Toolbar.js, line 126 Returns: Slider für die Neigung Type jQuery renderModelValues() Aktualisiert die Slider und Werte in der Toolbar anhand des verknüpften Modells. Source: View/Toolbar.js, line 93 setOrientation(orientation, isSlider) Setzen der Orientierung. Außerdem wird der Slider an die korrekte Position verschoben. Parameters: Name Type Description orientation number Wert für den Slider. isSlider boolean Gibt an ob der Aufruf der Funktion durch einen Slider durchgeführt wird. Source: View/Toolbar.js, line 182 showMore() Zeigt die weiteren Einstellungen und passt die entsprechenden Elemente an. Source: View/Toolbar.js, line 77 unbindEvents() Alle Eventlistener werden entkoppelt und die Toolbar wird für den Nutzer versteckt. Source: View/Toolbar.js, line 205 widthSlider() Gewährt den Zugriff auf das Slider Element für die Breite und gleichzeitig werdendie Werte bei einer Änderung in der Ansicht aktualisiert. Source: View/Toolbar.js, line 141 Returns: Slider für die Breite Type jQuery × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
